This S\+DK includes a number of sample applications. Each sample documents a feature of the S\+DK in both prose and the associated C code. The following samples are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_decode_to_md5}{decode\+\_\+to\+\_\+md5} Frame by frame M\+D5 checksum.
\item \hyperlink{example_decode_with_drops}{decode\+\_\+with\+\_\+drops} Drops frames while decoding.
\item \hyperlink{example_simple_decoder}{simple\+\_\+decoder} Simplified decoder loop.
\item \hyperlink{example_lossless_encoder}{lossless\+\_\+encoder} Simplified lossless encoder.
\item \hyperlink{example_set_maps}{set\+\_\+maps} Set active and R\+OI maps.
\item \hyperlink{example_simple_encoder}{simple\+\_\+encoder} Simplified encoder loop.
\item \hyperlink{example_twopass_encoder}{twopass\+\_\+encoder} Two-\/pass encoder loop.
\item \hyperlink{example_scalable_encoder}{scalable\+\_\+encoder} Scalable encoder loop.
\item \hyperlink{example_aom_cx_set_ref}{aom\+\_\+cx\+\_\+set\+\_\+ref} Set encoder reference frame.
\item \hyperlink{example_lightfield_encoder}{lightfield\+\_\+encoder} Lightfield encoder example.
\item \hyperlink{example_lightfield_tile_list_decoder}{lightfield\+\_\+tile\+\_\+list\+\_\+decoder} Lightfield tile list decoder example.
\item \hyperlink{example_lightfield_decoder}{lightfield\+\_\+decoder} Lightfield decoder example.
\item \hyperlink{example_lightfield_bitstream_parsing}{lightfield\+\_\+bitstream\+\_\+parsing} Lightfield bitstream parsing example.
\end{DoxyItemize}

In addition, the S\+DK contains a number of utilities. Since these utilities are built upon the concepts described in the sample code listed above, they are not documented in pieces like the samples are. Their source is included here for reference. The following utilities are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_aomdec}{aomdec} Full featured decoder.
\item \hyperlink{example_aomenc}{aomenc} Full featured encoder. 
\end{DoxyItemize}\hypertarget{example_decode_to_md5}{}\subsection{decode\+\_\+to\+\_\+md5}\label{example_decode_to_md5}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Frame-by-frame MD5 Checksum}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This example builds upon the simple decoder loop to show how checksums}
16 \textcolor{comment}{// of the decoded output can be generated. These are used for validating}
17 \textcolor{comment}{// decoder implementations against the reference implementation, for example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// MD5 algorithm}
20 \textcolor{comment}{// -------------}
21 \textcolor{comment}{// The Message-Digest 5 (MD5) is a well known hash function. We have provided}
22 \textcolor{comment}{// an implementation derived from the RSA Data Security, Inc. MD5 Message-Digest}
23 \textcolor{comment}{// Algorithm for your use. Our implmentation only changes the interface of this}
24 \textcolor{comment}{// reference code. You must include the `md5\_utils.h` header for access to these}
25 \textcolor{comment}{// functions.}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Processing The Decoded Data}
28 \textcolor{comment}{// ---------------------------}
29 \textcolor{comment}{// Each row of the image is passed to the MD5 accumulator. First the Y plane}
30 \textcolor{comment}{// is processed, then U, then V. It is important to honor the image's `stride`}
31 \textcolor{comment}{// values.}
32 
33 \textcolor{preprocessor}{#include <stdio.h>}
34 \textcolor{preprocessor}{#include <stdlib.h>}
35 \textcolor{preprocessor}{#include <string.h>}
36 
37 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
38 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
39 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
40 \textcolor{preprocessor}{#include "common/tools\_common.h"}
41 \textcolor{preprocessor}{#include "common/video\_reader.h"}
42 
43 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_image\_md5(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
44   \textcolor{keywordtype}{int} plane, y;
45   MD5Context md5;
46 
47   MD5Init(&md5);
48 
49   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
50     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[plane];
51     \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[plane];
52     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = plane ? (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} + 1) >> 1 : img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
53     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = plane ? (img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} + 1) >> 1 : img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
54 
55     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
56       MD5Update(&md5, buf, w);
57       buf += stride;
58     \}
59   \}
60 
61   MD5Final(digest, &md5);
62 \}
63 
64 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(FILE *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
65   \textcolor{keywordtype}{int} i;
66 
67   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) fprintf(stream, \textcolor{stringliteral}{"%02x"}, digest[i]);
68 \}
69 
70 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
71 
72 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
73   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
74   exit(EXIT\_FAILURE);
75 \}
76 
77 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
78   \textcolor{keywordtype}{int} frame\_cnt = 0;
79   FILE *outfile = NULL;
80   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
81   AvxVideoReader *reader = NULL;
82   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
83   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
84 
85   exec\_name = argv[0];
86 
87   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
88 
89   reader = aom\_video\_reader\_open(argv[1]);
90   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
91 
92   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
93     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
94 
95   info = aom\_video\_reader\_get\_info(reader);
96 
97   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
98   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
99 
100   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
101 
102   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
103     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder"});
104 
105   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
106     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
107     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
108     \textcolor{keywordtype}{size\_t} frame\_size = 0;
109     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
110         aom\_video\_reader\_get\_frame(reader, &frame\_size);
111     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
112       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame"});
113 
114     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
115       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16];
116 
117       get\_image\_md5(img, digest);
118       print\_md5(outfile, digest);
119       fprintf(outfile, \textcolor{stringliteral}{"  img-%dx%d-%04d.i420\(\backslash\)n"}, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
120               ++frame\_cnt);
121     \}
122   \}
123 
124   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
125   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
126 
127   aom\_video\_reader\_close(reader);
128 
129   fclose(outfile);
130   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
131 \}
\end{DoxyCodeInclude}
 \hypertarget{example_decode_with_drops}{}\subsection{decode\+\_\+with\+\_\+drops}\label{example_decode_with_drops}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Decode With Drops Example}
13 \textcolor{comment}{// =========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example utility which drops a series of frames, as specified}
16 \textcolor{comment}{// on the command line. This is useful for observing the error recovery}
17 \textcolor{comment}{// features of the codec.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Usage}
20 \textcolor{comment}{// -----}
21 \textcolor{comment}{// This example adds a single argument to the `simple\_decoder` example,}
22 \textcolor{comment}{// which specifies the range or pattern of frames to drop. The parameter is}
23 \textcolor{comment}{// parsed as follows:}
24 \textcolor{comment}{//}
25 \textcolor{comment}{// Dropping A Range Of Frames}
26 \textcolor{comment}{// --------------------------}
27 \textcolor{comment}{// To drop a range of frames, specify the starting frame and the ending}
28 \textcolor{comment}{// frame to drop, separated by a dash. The following command will drop}
29 \textcolor{comment}{// frames 5 through 10 (base 1).}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 5-10}
32 \textcolor{comment}{//}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Dropping A Pattern Of Frames}
35 \textcolor{comment}{// ----------------------------}
36 \textcolor{comment}{// To drop a pattern of frames, specify the number of frames to drop and}
37 \textcolor{comment}{// the number of frames after which to repeat the pattern, separated by}
38 \textcolor{comment}{// a forward-slash. The following command will drop 3 of 7 frames.}
39 \textcolor{comment}{// Specifically, it will decode 4 frames, then drop 3 frames, and then}
40 \textcolor{comment}{// repeat.}
41 \textcolor{comment}{//}
42 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 3/7}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Extra Variables}
46 \textcolor{comment}{// ---------------}
47 \textcolor{comment}{// This example maintains the pattern passed on the command line in the}
48 \textcolor{comment}{// `n`, `m`, and `is\_range` variables:}
49 \textcolor{comment}{//}
50 \textcolor{comment}{//}
51 \textcolor{comment}{// Making The Drop Decision}
52 \textcolor{comment}{// ------------------------}
53 \textcolor{comment}{// The example decides whether to drop the frame based on the current}
54 \textcolor{comment}{// frame number, immediately before decoding the frame.}
55 
56 \textcolor{preprocessor}{#include <stdio.h>}
57 \textcolor{preprocessor}{#include <stdlib.h>}
58 \textcolor{preprocessor}{#include <string.h>}
59 
60 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
61 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
62 \textcolor{preprocessor}{#include "common/tools\_common.h"}
63 \textcolor{preprocessor}{#include "common/video\_reader.h"}
64 
65 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
66 
67 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
68   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <N-M|N/M>\(\backslash\)n"}, exec\_name);
69   exit(EXIT\_FAILURE);
70 \}
71 
72 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
73   \textcolor{keywordtype}{int} frame\_cnt = 0;
74   FILE *outfile = NULL;
75   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
76   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
77   AvxVideoReader *reader = NULL;
78   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
79   \textcolor{keywordtype}{int} n = 0;
80   \textcolor{keywordtype}{int} m = 0;
81   \textcolor{keywordtype}{int} is\_range = 0;
82   \textcolor{keywordtype}{char} *nptr = NULL;
83 
84   exec\_name = argv[0];
85 
86   \textcolor{keywordflow}{if} (argc != 4) die(\textcolor{stringliteral}{"Invalid number of arguments."});
87 
88   reader = aom\_video\_reader\_open(argv[1]);
89   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
90 
91   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
92     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
93 
94   n = (int)strtol(argv[3], &nptr, 0);
95   m = (int)strtol(nptr + 1, NULL, 0);
96   is\_range = (*nptr == \textcolor{charliteral}{'-'});
97   \textcolor{keywordflow}{if} (!n || !m || (*nptr != \textcolor{charliteral}{'-'} && *nptr != \textcolor{charliteral}{'/'}))
98     die(\textcolor{stringliteral}{"Couldn't parse pattern %s.\(\backslash\)n"}, argv[3]);
99 
100   info = aom\_video\_reader\_get\_info(reader);
101 
102   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
103   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
104 
105   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
106 
107   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
108     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
109 
110   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
111     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
112     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
113     \textcolor{keywordtype}{size\_t} frame\_size = 0;
114     \textcolor{keywordtype}{int} skip;
115     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
116         aom\_video\_reader\_get\_frame(reader, &frame\_size);
117     ++frame\_cnt;
118 
119     skip = (is\_range && frame\_cnt >= n && frame\_cnt <= m) ||
120            (!is\_range && m - (frame\_cnt - 1) % m <= n);
121 
122     \textcolor{keywordflow}{if} (!skip) \{
123       putc(\textcolor{charliteral}{'.'}, stdout);
124       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
125         die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
126 
127       \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL)
128         aom\_img\_write(img, outfile);
129     \} \textcolor{keywordflow}{else} \{
130       putc(\textcolor{charliteral}{'X'}, stdout);
131     \}
132 
133     fflush(stdout);
134   \}
135 
136   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
137   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
138 
139   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
140          info->frame\_width, info->frame\_height, argv[2]);
141 
142   aom\_video\_reader\_close(reader);
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_decoder}{}\subsection{simple\+\_\+decoder}\label{example_simple_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Decoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple decoder loop. It takes an input file}
16 \textcolor{comment}{// containing the compressed data (in IVF format), passes it through the}
17 \textcolor{comment}{// decoder, and writes the decompressed frames to disk. Other decoder}
18 \textcolor{comment}{// examples build upon this one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For decoders, you only have to include `aom\_decoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Initializing The Codec}
35 \textcolor{comment}{// ----------------------}
36 \textcolor{comment}{// The libaom decoder is initialized by the call to aom\_codec\_dec\_init().}
37 \textcolor{comment}{// Determining the codec interface to use is handled by AvxVideoReader and the}
38 \textcolor{comment}{// functions prefixed with aom\_video\_reader\_. Discussion of those functions is}
39 \textcolor{comment}{// beyond the scope of this example, but the main gist is to open the input file}
40 \textcolor{comment}{// and parse just enough of it to determine if it's a AVx file and which AVx}
41 \textcolor{comment}{// codec is contained within the file.}
42 \textcolor{comment}{// Note the NULL pointer passed to aom\_codec\_dec\_init(). We do that in this}
43 \textcolor{comment}{// example because we want the algorithm to determine the stream configuration}
44 \textcolor{comment}{// (width/height) and allocate memory automatically.}
45 \textcolor{comment}{//}
46 \textcolor{comment}{// Decoding A Frame}
47 \textcolor{comment}{// ----------------}
48 \textcolor{comment}{// Once the frame has been read into memory, it is decoded using the}
49 \textcolor{comment}{// `aom\_codec\_decode` function. The call takes a pointer to the data}
50 \textcolor{comment}{// (`frame`) and the length of the data (`frame\_size`). No application data}
51 \textcolor{comment}{// is associated with the frame in this example, so the `user\_priv`}
52 \textcolor{comment}{// parameter is NULL.}
53 \textcolor{comment}{//}
54 \textcolor{comment}{// Codecs may produce a variable number of output frames for every call to}
55 \textcolor{comment}{// `aom\_codec\_decode`. These frames are retrieved by the}
56 \textcolor{comment}{// `aom\_codec\_get\_frame` iterator function. The iterator variable `iter` is}
57 \textcolor{comment}{// initialized to NULL each time `aom\_codec\_decode` is called.}
58 \textcolor{comment}{// `aom\_codec\_get\_frame` is called in a loop, returning a pointer to a}
59 \textcolor{comment}{// decoded image or NULL to indicate the end of list.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Processing The Decoded Data}
62 \textcolor{comment}{// ---------------------------}
63 \textcolor{comment}{// In this example, we simply write the encoded data to disk. It is}
64 \textcolor{comment}{// important to honor the image's `stride` values.}
65 \textcolor{comment}{//}
66 \textcolor{comment}{// Cleanup}
67 \textcolor{comment}{// -------}
68 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
69 \textcolor{comment}{//}
70 \textcolor{comment}{// Error Handling}
71 \textcolor{comment}{// --------------}
72 \textcolor{comment}{// This example does not special case any error return codes. If there was}
73 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
74 \textcolor{comment}{// few exceptions, aom\_codec functions return an enumerated error status,}
75 \textcolor{comment}{// with the value `0` indicating success.}
76 
77 \textcolor{preprocessor}{#include <stdio.h>}
78 \textcolor{preprocessor}{#include <stdlib.h>}
79 \textcolor{preprocessor}{#include <string.h>}
80 
81 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
82 \textcolor{preprocessor}{#include "common/tools\_common.h"}
83 \textcolor{preprocessor}{#include "common/video\_reader.h"}
84 
85 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
86 
87 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
88   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
89   exit(EXIT\_FAILURE);
90 \}
91 
92 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
93   \textcolor{keywordtype}{int} frame\_cnt = 0;
94   FILE *outfile = NULL;
95   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
96   AvxVideoReader *reader = NULL;
97   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
98   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
99 
100   exec\_name = argv[0];
101 
102   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
103 
104   reader = aom\_video\_reader\_open(argv[1]);
105   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
106 
107   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
108     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
109 
110   info = aom\_video\_reader\_get\_info(reader);
111 
112   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
113   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
114 
115   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
116 
117   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
118     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
119 
120   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
121     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
122     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
123     \textcolor{keywordtype}{size\_t} frame\_size = 0;
124     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
125         aom\_video\_reader\_get\_frame(reader, &frame\_size);
126     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
127       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
128 
129     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
130       aom\_img\_write(img, outfile);
131       ++frame\_cnt;
132     \}
133   \}
134 
135   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
136   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
137 
138   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
139          info->frame\_width, info->frame\_height, argv[2]);
140 
141   aom\_video\_reader\_close(reader);
142 
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lossless_encoder}{}\subsection{lossless\+\_\+encoder}\label{example_lossless_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <stdio.h>}
13 \textcolor{preprocessor}{#include <stdlib.h>}
14 \textcolor{preprocessor}{#include <string.h>}
15 
16 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
17 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
18 \textcolor{preprocessor}{#include "common/tools\_common.h"}
19 \textcolor{preprocessor}{#include "common/video\_writer.h"}
20 
21 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
22 
23 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
24   fprintf(stderr,
25           \textcolor{stringliteral}{"lossless\_encoder: Example demonstrating lossless "}
26           \textcolor{stringliteral}{"encoding feature. Supports raw input only.\(\backslash\)n"});
27   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <width> <height> <infile> <outfile>\(\backslash\)n"}, exec\_name);
28   exit(EXIT\_FAILURE);
29 \}
30 
31 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
32                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
33   \textcolor{keywordtype}{int} got\_pkts = 0;
34   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
35   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
36   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
37       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
38   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
39 
40   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
41     got\_pkts = 1;
42 
43     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
44       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
45       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
46                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
47                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
48         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
49       \}
50       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
51       fflush(stdout);
52     \}
53   \}
54 
55   \textcolor{keywordflow}{return} got\_pkts;
56 \}
57 
58 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
59   FILE *infile = NULL;
60   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
61   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
62   \textcolor{keywordtype}{int} frame\_count = 0;
63   \hyperlink{structaom__image}{aom\_image\_t} raw;
64   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
65   AvxVideoInfo info;
66   AvxVideoWriter *writer = NULL;
67   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
68   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
69 
70   exec\_name = argv[0];
71 
72   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
73   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
74   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
75 
76   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments"});
77 
78   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
79   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
80 
81   info.codec\_fourcc = encoder->fourcc;
82   info.frame\_width = (int)strtol(argv[1], NULL, 0);
83   info.frame\_height = (int)strtol(argv[2], NULL, 0);
84   info.time\_base.numerator = 1;
85   info.time\_base.denominator = fps;
86 
87   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
88       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
89     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
90   \}
91 
92   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
93                      info.frame\_height, 1)) \{
94     die(\textcolor{stringliteral}{"Failed to allocate image."});
95   \}
96 
97   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
98 
99   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
100   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
101 
102   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
103   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
104   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
105   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
106 
107   writer = aom\_video\_writer\_open(argv[4], kContainerIVF, &info);
108   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[4]);
109 
110   \textcolor{keywordflow}{if} (!(infile = fopen(argv[3], \textcolor{stringliteral}{"rb"})))
111     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[3]);
112 
113   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
114     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
115 
116   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS}, 1))
117     die\_codec(&codec, \textcolor{stringliteral}{"Failed to use lossless mode"});
118 
119   \textcolor{comment}{// Encode frames.}
120   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
121     encode\_frame(&codec, &raw, frame\_count++, 0, writer);
122   \}
123 
124   \textcolor{comment}{// Flush encoder.}
125   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \{
126   \}
127 
128   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
129   fclose(infile);
130   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
131 
132   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
133   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
134 
135   aom\_video\_writer\_close(writer);
136 
137   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
138 \}
\end{DoxyCodeInclude}
 \hypertarget{example_set_maps}{}\subsection{set\+\_\+maps}\label{example_set_maps}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AOM Set Active and ROI Maps}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to control the AOM encoder's}
16 \textcolor{comment}{// ROI and Active maps.}
17 \textcolor{comment}{//}
18 \textcolor{comment}{// ROI (Reigon of Interest) maps are a way for the application to assign}
19 \textcolor{comment}{// each macroblock in the image to a region, and then set quantizer and}
20 \textcolor{comment}{// filtering parameters on that image.}
21 \textcolor{comment}{//}
22 \textcolor{comment}{// Active maps are a way for the application to specify on a}
23 \textcolor{comment}{// macroblock-by-macroblock basis whether there is any activity in that}
24 \textcolor{comment}{// macroblock.}
25 \textcolor{comment}{//}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Configuration}
28 \textcolor{comment}{// -------------}
29 \textcolor{comment}{// An ROI map is set on frame 22. If the width of the image in macroblocks}
30 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
31 \textcolor{comment}{// columns, where the quantizer, loopfilter, and static threshold differ}
32 \textcolor{comment}{// from column to column.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// An active map is set on frame 33. If the width of the image in macroblocks}
35 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
36 \textcolor{comment}{// columns, where one column will have motion and the next will not.}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// The active map is cleared on frame 44.}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Observing The Effects}
41 \textcolor{comment}{// ---------------------}
42 \textcolor{comment}{// Use the `simple\_decoder` example to decode this sample, and observe}
43 \textcolor{comment}{// the change in the image at frames 22, 33, and 44.}
44 
45 \textcolor{preprocessor}{#include <assert.h>}
46 \textcolor{preprocessor}{#include <stdio.h>}
47 \textcolor{preprocessor}{#include <stdlib.h>}
48 \textcolor{preprocessor}{#include <string.h>}
49 
50 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
51 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
52 \textcolor{preprocessor}{#include "common/tools\_common.h"}
53 \textcolor{preprocessor}{#include "common/video\_writer.h"}
54 
55 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
56 
57 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
58   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile>\(\backslash\)n"},
59           exec\_name);
60   exit(EXIT\_FAILURE);
61 \}
62 
63 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
64                            \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
65   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
66   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
67 
68   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
69   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
70 
71   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = (uint8\_t *)malloc(map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols});
72   \textcolor{keywordflow}{for} (i = 0; i < map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols}; ++i) map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map}[i] = i % 2;
73 
74   if (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
75     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
76 
77   free(map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map});
78 \}
79 
80 \textcolor{keyword}{static} \textcolor{keywordtype}{void} unset\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
81                              \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
82   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
83 
84   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
85   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
86   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = NULL;
87 
88   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
89     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
93                         \textcolor{keywordtype}{int} frame\_index, AvxVideoWriter *writer) \{
94   \textcolor{keywordtype}{int} got\_pkts = 0;
95   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
96   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
97   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, 0
      );
98   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
99 
100   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
101     got\_pkts = 1;
102 
103     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
104       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
105       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
106                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
107                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
108         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
109       \}
110 
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
120   FILE *infile = NULL;
121   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
122   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \textcolor{keyword}{const} \textcolor{keywordtype}{int} limit = 15;
125   \hyperlink{structaom__image}{aom\_image\_t} raw;
126   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
127   AvxVideoInfo info;
128   AvxVideoWriter *writer = NULL;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 2;  \textcolor{comment}{// TODO(dkovalev) add command line argument}
131   \textcolor{keyword}{const} \textcolor{keywordtype}{double} bits\_per\_pixel\_per\_frame = 0.067;
132 
133   exec\_name = argv[0];
134   \textcolor{keywordflow}{if} (argc != 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
135 
136   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
137 
138   encoder = get\_aom\_encoder\_by\_name(argv[1]);
139   \textcolor{keywordflow}{if} (encoder == NULL) \{
140     die(\textcolor{stringliteral}{"Unsupported codec."});
141   \}
142   assert(encoder != NULL);
143   info.codec\_fourcc = encoder->fourcc;
144   info.frame\_width = (int)strtol(argv[2], NULL, 0);
145   info.frame\_height = (int)strtol(argv[3], NULL, 0);
146   info.time\_base.numerator = 1;
147   info.time\_base.denominator = fps;
148 
149   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
150       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
151     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
152   \}
153 
154   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
155                      info.frame\_height, 1)) \{
156     die(\textcolor{stringliteral}{"Failed to allocate image."});
157   \}
158 
159   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
160 
161   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
162   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
163 
164   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
165   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
166   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
167   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
168   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} =
169       (\textcolor{keywordtype}{unsigned} int)(bits\_per\_pixel\_per\_frame * cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} * cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} * fps / 1000);
170   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
171 
172   writer = aom\_video\_writer\_open(argv[5], kContainerIVF, &info);
173   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[5]);
174 
175   \textcolor{keywordflow}{if} (!(infile = fopen(argv[4], \textcolor{stringliteral}{"rb"})))
176     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[4]);
177 
178   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
179     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
180 
181   \textcolor{comment}{// Encode frames.}
182   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile) && frame\_count < limit) \{
183     ++frame\_count;
184 
185     \textcolor{keywordflow}{if} (frame\_count == 5) \{
186       set\_active\_map(&cfg, &codec);
187     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (frame\_count == 11) \{
188       unset\_active\_map(&cfg, &codec);
189     \}
190 
191     encode\_frame(&codec, &raw, frame\_count, writer);
192   \}
193 
194   \textcolor{comment}{// Flush encoder.}
195   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, writer)) \{
196   \}
197 
198   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
199   fclose(infile);
200   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
201 
202   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
203   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
204 
205   aom\_video\_writer\_close(writer);
206 
207   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
208 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_encoder}{}\subsection{simple\+\_\+encoder}\label{example_simple_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. Other decoder examples build upon this}
18 \textcolor{comment}{// one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For encoders, you only have to include `aom\_encoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Getting The Default Configuration}
35 \textcolor{comment}{// ---------------------------------}
36 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
37 \textcolor{comment}{// may want to publish default configurations for both a video}
38 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
39 \textcolor{comment}{// obviously have very different default settings. Consult the}
40 \textcolor{comment}{// documentation for your codec to see if it provides any default}
41 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
42 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Updating The Configuration}
45 \textcolor{comment}{// ---------------------------------}
46 \textcolor{comment}{// Almost all applications will want to update the default configuration}
47 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
48 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
49 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
50 \textcolor{comment}{// and the resolution specified on the command line.}
51 \textcolor{comment}{//}
52 \textcolor{comment}{// Initializing The Codec}
53 \textcolor{comment}{// ----------------------}
54 \textcolor{comment}{// The encoder is initialized by the following code.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Encoding A Frame}
57 \textcolor{comment}{// ----------------}
58 \textcolor{comment}{// The frame is read as a continuous block (size width * height * 3 / 2)}
59 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
60 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
61 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
62 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
63 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
64 \textcolor{comment}{// unused in this example.}
65 
66 \textcolor{comment}{// Forced Keyframes}
67 \textcolor{comment}{// ----------------}
68 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
69 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
70 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
71 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
72 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
73 \textcolor{comment}{// encoder.}
74 \textcolor{comment}{//}
75 \textcolor{comment}{// Processing The Encoded Data}
76 \textcolor{comment}{// ---------------------------}
77 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
78 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
79 \textcolor{comment}{//}
80 \textcolor{comment}{// Cleanup}
81 \textcolor{comment}{// -------}
82 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
83 \textcolor{comment}{//}
84 \textcolor{comment}{// Error Handling}
85 \textcolor{comment}{// --------------}
86 \textcolor{comment}{// This example does not special case any error return codes. If there was}
87 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
88 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
89 \textcolor{comment}{// with the value `0` indicating success.}
90 \textcolor{comment}{//}
91 \textcolor{comment}{// Error Resiliency Features}
92 \textcolor{comment}{// -------------------------}
93 \textcolor{comment}{// Error resiliency is controlled by the g\_error\_resilient member of the}
94 \textcolor{comment}{// configuration structure. Use the `decode\_with\_drops` example to decode with}
95 \textcolor{comment}{// frames 5-10 dropped. Compare the output for a file encoded with this example}
96 \textcolor{comment}{// versus one encoded with the `simple\_encoder` example.}
97 
98 \textcolor{preprocessor}{#include <stdio.h>}
99 \textcolor{preprocessor}{#include <stdlib.h>}
100 \textcolor{preprocessor}{#include <string.h>}
101 
102 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
103 \textcolor{preprocessor}{#include "common/tools\_common.h"}
104 \textcolor{preprocessor}{#include "common/video\_writer.h"}
105 
106 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
107 
108 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
109   fprintf(stderr,
110           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
111           \textcolor{stringliteral}{"<keyframe-interval> <error-resilient> <frames to encode>\(\backslash\)n"}
112           \textcolor{stringliteral}{"See comments in simple\_encoder.c for more information.\(\backslash\)n"},
113           exec\_name);
114   exit(EXIT\_FAILURE);
115 \}
116 
117 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
118                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
119   \textcolor{keywordtype}{int} got\_pkts = 0;
120   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
121   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
122   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
123       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
124   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
125 
126   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
127     got\_pkts = 1;
128 
129     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
130       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
131       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
132                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
133                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
134         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
135       \}
136       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
137       fflush(stdout);
138     \}
139   \}
140 
141   \textcolor{keywordflow}{return} got\_pkts;
142 \}
143 
144 \textcolor{comment}{// TODO(tomfinegan): Improve command line parsing and add args for bitrate/fps.}
145 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
146   FILE *infile = NULL;
147   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
148   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
149   \textcolor{keywordtype}{int} frame\_count = 0;
150   \hyperlink{structaom__image}{aom\_image\_t} raw;
151   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
152   AvxVideoInfo info;
153   AvxVideoWriter *writer = NULL;
154   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
155   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
156   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
157   \textcolor{keywordtype}{int} keyframe\_interval = 0;
158   \textcolor{keywordtype}{int} max\_frames = 0;
159   \textcolor{keywordtype}{int} frames\_encoded = 0;
160   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
161   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
162   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
163   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
164   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
165   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *keyframe\_interval\_arg = NULL;
166 
167   exec\_name = argv[0];
168 
169   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
170   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
171   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
172 
173   \textcolor{keywordflow}{if} (argc != 9) die(\textcolor{stringliteral}{"Invalid number of arguments"});
174 
175   codec\_arg = argv[1];
176   width\_arg = argv[2];
177   height\_arg = argv[3];
178   infile\_arg = argv[4];
179   outfile\_arg = argv[5];
180   keyframe\_interval\_arg = argv[6];
181   max\_frames = (int)strtol(argv[8], NULL, 0);
182 
183   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
184   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
185 
186   info.codec\_fourcc = encoder->fourcc;
187   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
188   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
189   info.time\_base.numerator = 1;
190   info.time\_base.denominator = fps;
191 
192   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
193       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
194     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
195   \}
196 
197   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
198                      info.frame\_height, 1)) \{
199     die(\textcolor{stringliteral}{"Failed to allocate image."});
200   \}
201 
202   keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);
203   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
204 
205   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
206 
207   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
208   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
209 
210   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
211   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
212   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
213   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
214   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
215   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = (\hyperlink{group__encoder_ga5f326af84993f371bb165883bb5a5a59}{aom\_codec\_er\_flags\_t})strtoul(argv[7], NULL,
       0);
216 
217   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
218   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
219 
220   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
221     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
222 
223   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
224     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
225 
226   \textcolor{comment}{// Encode frames.}
227   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
228     \textcolor{keywordtype}{int} flags = 0;
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frame\_count % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     encode\_frame(&codec, &raw, frame\_count++, flags, writer);
232     frames\_encoded++;
233     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
234   \}
235 
236   \textcolor{comment}{// Flush encoder.}
237   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \textcolor{keywordflow}{continue};
238 
239   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
240   fclose(infile);
241   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
242 
243   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
244   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
245 
246   aom\_video\_writer\_close(writer);
247 
248   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
249 \}
\end{DoxyCodeInclude}
 \hypertarget{example_twopass_encoder}{}\subsection{twopass\+\_\+encoder}\label{example_twopass_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Two Pass Encoder}
13 \textcolor{comment}{// ================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a two pass encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder twice, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. It builds upon the simple\_encoder example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Twopass Variables}
20 \textcolor{comment}{// -----------------}
21 \textcolor{comment}{// Twopass mode needs to track the current pass number and the buffer of}
22 \textcolor{comment}{// statistics packets.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Updating The Configuration}
25 \textcolor{comment}{// ---------------------------------}
26 \textcolor{comment}{// In two pass mode, the configuration has to be updated on each pass. The}
27 \textcolor{comment}{// statistics buffer is passed on the last pass.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Encoding A Frame}
30 \textcolor{comment}{// ----------------}
31 \textcolor{comment}{// Encoding a frame in two pass mode is identical to the simple encoder}
32 \textcolor{comment}{// example.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Processing Statistics Packets}
35 \textcolor{comment}{// -----------------------------}
36 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
37 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
38 \textcolor{comment}{//}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Pass Progress Reporting}
41 \textcolor{comment}{// -----------------------------}
42 \textcolor{comment}{// It's sometimes helpful to see when each pass completes.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Clean-up}
46 \textcolor{comment}{// -----------------------------}
47 \textcolor{comment}{// Destruction of the encoder instance must be done on each pass. The}
48 \textcolor{comment}{// raw image should be destroyed at the end as usual.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
55 \textcolor{preprocessor}{#include "common/tools\_common.h"}
56 \textcolor{preprocessor}{#include "common/video\_writer.h"}
57 
58 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
59 
60 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
61   fprintf(stderr,
62           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
63           \textcolor{stringliteral}{"<limit(optional)>\(\backslash\)n"},
64           exec\_name);
65   exit(EXIT\_FAILURE);
66 \}
67 
68 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
69                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
70                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
71                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
72   \textcolor{keywordtype}{int} got\_pkts = 0;
73   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
74   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
75   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
76   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
77 
78   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
79     got\_pkts = 1;
80 
81     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
82       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
83       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
84       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
85       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
86       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
87     \}
88   \}
89 
90   \textcolor{keywordflow}{return} got\_pkts;
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
95                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
96   \textcolor{keywordtype}{int} got\_pkts = 0;
97   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
98   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
99   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
103     got\_pkts = 1;
104     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
105       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
106 
107       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
108                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
109                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
110         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
120                              \textcolor{keyword}{const} AvxInterface *encoder,
121                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} limit) \{
122   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
125 
126   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
127     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
128 
129   \textcolor{comment}{// Calculate frame statistics.}
130   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
131     ++frame\_count;
132     get\_frame\_stats(&codec, raw, frame\_count, 1, 0, &stats);
133   \}
134 
135   \textcolor{comment}{// Flush encoder.}
136   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
137   \}
138 
139   printf(\textcolor{stringliteral}{"Pass 0 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
140   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
141 
142   \textcolor{keywordflow}{return} stats;
143 \}
144 
145 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
146                   \textcolor{keyword}{const} AvxInterface *encoder, \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
147                   \textcolor{keywordtype}{int} limit) \{
148   AvxVideoInfo info = \{ encoder->fourcc,
149                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
150                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
151                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \} \};
152   AvxVideoWriter *writer = NULL;
153   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
154   \textcolor{keywordtype}{int} frame\_count = 0;
155 
156   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
157   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
158 
159   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
160     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
161 
162   \textcolor{comment}{// Encode frames.}
163   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
164     ++frame\_count;
165     encode\_frame(&codec, raw, frame\_count, 1, 0, writer);
166   \}
167 
168   \textcolor{comment}{// Flush encoder.}
169   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
170   \}
171 
172   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
173 
174   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
175 
176   aom\_video\_writer\_close(writer);
177 
178   printf(\textcolor{stringliteral}{"Pass 1 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
179 \}
180 
181 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
182   FILE *infile = NULL;
183   \textcolor{keywordtype}{int} w, h;
184   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
185   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
186   \hyperlink{structaom__image}{aom\_image\_t} raw;
187   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
188   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
189 
190   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
191   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;       \textcolor{comment}{// TODO(dkovalev) add command line argument}
192   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s TODO(dkovalev) add command line argument}
193   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} codec\_arg = argv[1];
194   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[2];
195   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[3];
196   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[4];
197   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[5];
198   \textcolor{keywordtype}{int} limit = 0;
199   exec\_name = argv[0];
200 
201   \textcolor{keywordflow}{if} (argc < 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
202 
203   \textcolor{keywordflow}{if} (argc > 6) limit = (int)strtol(argv[6], NULL, 0);
204 
205   \textcolor{keywordflow}{if} (limit == 0) limit = 100;
206 
207   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
208   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
209 
210   w = (int)strtol(width\_arg, NULL, 0);
211   h = (int)strtol(height\_arg, NULL, 0);
212 
213   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
214     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
215 
216   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 1))
217     die(\textcolor{stringliteral}{"Failed to allocate image"}, w, h);
218 
219   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
220 
221   \textcolor{comment}{// Configuration}
222   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
223   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
224 
225   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
226   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
227   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
228   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
229   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
230 
231   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
232     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
233 
234   \textcolor{comment}{// Pass 0}
235   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
236   stats = pass0(&raw, infile, encoder, &cfg, limit);
237 
238   \textcolor{comment}{// Pass 1}
239   rewind(infile);
240   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
241   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
242   pass1(&raw, infile, outfile\_arg, encoder, &cfg, limit);
243   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
244 
245   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
246   fclose(infile);
247 
248   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
249 \}
\end{DoxyCodeInclude}
 \hypertarget{example_scalable_encoder}{}\subsection{scalable\+\_\+encoder}\label{example_scalable_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Scalable Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a scalable encoder loop. It takes two input files in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in OBU format.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Getting The Default Configuration}
20 \textcolor{comment}{// ---------------------------------}
21 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
22 \textcolor{comment}{// may want to publish default configurations for both a video}
23 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
24 \textcolor{comment}{// obviously have very different default settings. Consult the}
25 \textcolor{comment}{// documentation for your codec to see if it provides any default}
26 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
27 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Updating The Configuration}
30 \textcolor{comment}{// ---------------------------------}
31 \textcolor{comment}{// Almost all applications will want to update the default configuration}
32 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
33 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
34 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
35 \textcolor{comment}{// and the resolution specified on the command line.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{// Encoding A Frame}
38 \textcolor{comment}{// ----------------}
39 \textcolor{comment}{// The frame is read as a continuous block (size = width * height * 3 / 2)}
40 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
41 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
42 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
43 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
44 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
45 \textcolor{comment}{// unused in this example.}
46 
47 \textcolor{comment}{// Forced Keyframes}
48 \textcolor{comment}{// ----------------}
49 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
50 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
51 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
52 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
53 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
54 \textcolor{comment}{// encoder.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Processing The Encoded Data}
57 \textcolor{comment}{// ---------------------------}
58 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
59 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Cleanup}
62 \textcolor{comment}{// -------}
63 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
64 \textcolor{comment}{//}
65 \textcolor{comment}{// Error Handling}
66 \textcolor{comment}{// --------------}
67 \textcolor{comment}{// This example does not special case any error return codes. If there was}
68 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
69 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
70 \textcolor{comment}{// with the value `0` indicating success.}
71 
72 \textcolor{preprocessor}{#include <stdio.h>}
73 \textcolor{preprocessor}{#include <stdlib.h>}
74 \textcolor{preprocessor}{#include <string.h>}
75 
76 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
77 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
78 \textcolor{preprocessor}{#include "av1/common/enums.h"}
79 \textcolor{preprocessor}{#include "common/tools\_common.h"}
80 \textcolor{preprocessor}{#include "common/video\_writer.h"}
81 
82 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
83 
84 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
85   fprintf(stderr,
86           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile0> <infile1> "}
87           \textcolor{stringliteral}{"<outfile> <frames to encode>\(\backslash\)n"}
88           \textcolor{stringliteral}{"See comments in scalable\_encoder.c for more information.\(\backslash\)n"},
89           exec\_name);
90   exit(EXIT\_FAILURE);
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, FILE *outfile) \{
95   \textcolor{keywordtype}{int} got\_pkts = 0;
96   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
97   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
98   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
99       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
103     got\_pkts = 1;
104 
105     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
106       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
107       \textcolor{keywordflow}{if} (fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, outfile) !=
108           pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz) \{
109         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
110       \}
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       printf(\textcolor{stringliteral}{" %6d\(\backslash\)n"}, (\textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
113       fflush(stdout);
114     \}
115   \}
116 
117   \textcolor{keywordflow}{return} got\_pkts;
118 \}
119 
120 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
121   FILE *infile0 = NULL;
122   FILE *infile1 = NULL;
123   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
124   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
125   \textcolor{keywordtype}{int} frame\_count = 0;
126   \hyperlink{structaom__image}{aom\_image\_t} raw0, raw1;
127   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
128   AvxVideoInfo info;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
131   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
132   \textcolor{keywordtype}{int} keyframe\_interval = 0;
133   \textcolor{keywordtype}{int} max\_frames = 0;
134   \textcolor{keywordtype}{int} frames\_encoded = 0;
135   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
136   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
137   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
138   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile0\_arg = NULL;
139   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile1\_arg = NULL;
140   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
141   \textcolor{comment}{//  const char *keyframe\_interval\_arg = NULL;}
142   FILE *outfile = NULL;
143 
144   exec\_name = argv[0];
145 
146   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
147   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
148   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
149 
150   \textcolor{keywordflow}{if} (argc != 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
151 
152   codec\_arg = argv[1];
153   width\_arg = argv[2];
154   height\_arg = argv[3];
155   infile0\_arg = argv[4];
156   infile1\_arg = argv[5];
157   outfile\_arg = argv[6];
158   max\_frames = (int)strtol(argv[7], NULL, 0);
159 
160   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
161   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
162 
163   info.codec\_fourcc = encoder->fourcc;
164   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
165   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
166   info.time\_base.numerator = 1;
167   info.time\_base.denominator = fps;
168 
169   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
170       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
171     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
172   \}
173 
174   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw0, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
175                      info.frame\_height, 1)) \{
176     die(\textcolor{stringliteral}{"Failed to allocate image for layer 0."});
177   \}
178   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw1, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
179                      info.frame\_height, 1)) \{
180     die(\textcolor{stringliteral}{"Failed to allocate image for layer 1."});
181   \}
182 
183   \textcolor{comment}{//  keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);}
184   keyframe\_interval = 100;
185   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
186 
187   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
188 
189   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
190   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
191 
192   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
193   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
194   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
195   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
196   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
197   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;
198   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
199   cfg.\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
200   cfg.\hyperlink{structaom__codec__enc__cfg_adb3fe41c1ce39579a49b97bc2ca7b2f2}{save\_as\_annexb} = 0;
201 
202   outfile = fopen(outfile\_arg, \textcolor{stringliteral}{"wb"});
203   \textcolor{keywordflow}{if} (!outfile) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
204 
205   \textcolor{keywordflow}{if} (!(infile0 = fopen(infile0\_arg, \textcolor{stringliteral}{"rb"})))
206     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
207   \textcolor{keywordflow}{if} (!(infile1 = fopen(infile1\_arg, \textcolor{stringliteral}{"rb"})))
208     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
209 
210   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
211     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
212   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED}, 8))
213     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cpu to 8"});
214 
215   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 2))
216     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile columns to 2"});
217   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG}, 3))
218     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set num of tile groups to 3"});
219 
220   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aef4facbd3745aa7f2a604faaf68316ff}{AOME\_SET\_NUMBER\_SPATIAL\_LAYERS}
      , 2))
221     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set number of spatial layers to 2"});
222 
223   \textcolor{comment}{// Encode frames.}
224   \textcolor{keywordflow}{while} (aom\_img\_read(&raw0, infile0)) \{
225     \textcolor{keywordtype}{int} flags = 0;
226 
227     \textcolor{comment}{// configure and encode base layer}
228 
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frames\_encoded % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     \textcolor{keywordflow}{else}
232       \textcolor{comment}{// use previous base layer (LAST) as sole reference}
233       \textcolor{comment}{// save this frame as LAST to be used as reference by enhanmcent layer}
234       \textcolor{comment}{// and next base layer}
235       flags |= \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
236                \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
237                \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
238                \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
239                \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
240     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
241     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
242     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
243       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 0"});
244     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 0))
245       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 0"});
246     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 62))
247       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
248     encode\_frame(&codec, &raw0, frame\_count++, flags, outfile);
249 
250     \textcolor{comment}{// configure and encode enhancement layer}
251 
252     \textcolor{comment}{//  use LAST (base layer) as sole reference}
253     flags = \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
254             \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} | 
      \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} |
255             \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} | \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} |
256             \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
257             \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
258     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
259     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
260     aom\_img\_read(&raw1, infile1);
261     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
262       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 1"});
263     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 1))
264       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 1"});
265     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 10))
266       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
267     encode\_frame(&codec, &raw1, frame\_count++, flags, outfile);
268 
269     frames\_encoded++;
270 
271     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
272   \}
273 
274   \textcolor{comment}{// Flush encoder.}
275   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, outfile)) \textcolor{keywordflow}{continue};
276 
277   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
278   fclose(infile0);
279   fclose(infile1);
280   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count / 2);
281 
282   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw0);
283   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw1);
284   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
285 
286   fclose(outfile);
287 
288   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
289 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aom_cx_set_ref}{}\subsection{aom\+\_\+cx\+\_\+set\+\_\+ref}\label{example_aom_cx_set_ref}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AV1 Set Reference Frame}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to overwrite the AV1 encoder's}
16 \textcolor{comment}{// internal reference frame. In the sample we set the last frame to the}
17 \textcolor{comment}{// current frame. This technique could be used to bounce between two cameras.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// The decoder would also have to set the reference frame to the same value}
20 \textcolor{comment}{// on the same frame, or the video will become corrupt. The 'test\_decode'}
21 \textcolor{comment}{// variable is set to 1 in this example that tests if the encoder and decoder}
22 \textcolor{comment}{// results are matching.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Usage}
25 \textcolor{comment}{// -----}
26 \textcolor{comment}{// This example encodes a raw video. And the last argument passed in specifies}
27 \textcolor{comment}{// the frame number to update the reference frame on. For example, run}
28 \textcolor{comment}{// examples/aom\_cx\_set\_ref av1 352 288 in.yuv out.ivf 4 30}
29 \textcolor{comment}{// The parameter is parsed as follows:}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//}
32 \textcolor{comment}{// Extra Variables}
33 \textcolor{comment}{// ---------------}
34 \textcolor{comment}{// This example maintains the frame number passed on the command line}
35 \textcolor{comment}{// in the `update\_frame\_num` variable.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// Configuration}
39 \textcolor{comment}{// -------------}
40 \textcolor{comment}{//}
41 \textcolor{comment}{// The reference frame is updated on the frame specified on the command}
42 \textcolor{comment}{// line.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Observing The Effects}
45 \textcolor{comment}{// ---------------------}
46 \textcolor{comment}{// The encoder and decoder results should be matching when the same reference}
47 \textcolor{comment}{// frame setting operation is done in both encoder and decoder. Otherwise,}
48 \textcolor{comment}{// the encoder/decoder mismatch would be seen.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
55 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
56 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
57 \textcolor{preprocessor}{#include "common/tools\_common.h"}
58 \textcolor{preprocessor}{#include "common/video\_writer.h"}
59 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
60 
61 \textcolor{preprocessor}{#define AOM\_BORDER\_IN\_PIXELS 288}
62 
63 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
64 
65 \textcolor{keywordtype}{void} usage\_exit() \{
66   fprintf(stderr,
67           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
68           \textcolor{stringliteral}{"<frame> <limit(optional)>\(\backslash\)n"},
69           exec\_name);
70   exit(EXIT\_FAILURE);
71 \}
72 
73 \textcolor{keyword}{static} \textcolor{keywordtype}{void} testing\_decode(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *encoder, 
      \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *decoder,
74                            \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen) \{
75   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
76 
77   \textcolor{keywordflow}{if} (*mismatch\_seen) \textcolor{keywordflow}{return};
78 
79   \textcolor{comment}{/* Get the internal reference frame */}
80   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &enc\_img)
      )
81     die\_codec(encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
82   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &dec\_img)
      )
83     die\_codec(decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
84 
85   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
86       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
87     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
88       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
89       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
90                     enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
91       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
92       enc\_img = enc\_hbd\_img;
93     \}
94     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
95       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
96       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
97                     dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
98       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
99       dec\_img = dec\_hbd\_img;
100     \}
101   \}
102 
103   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
104     \textcolor{keywordtype}{int} y[4], u[4], v[4];
105     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
106       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
107     \} \textcolor{keywordflow}{else} \{
108       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
109     \}
110 
111     printf(
112         \textcolor{stringliteral}{"Encode/decode mismatch on frame %d at"}
113         \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
114         \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
115         \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
116         frame\_out, y[0], y[1], y[2], y[3], u[0], u[1], u[2], u[3], v[0], v[1],
117         v[2], v[3]);
118     *mismatch\_seen = 1;
119   \}
120 
121   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
122   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
123 \}
124 
125 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ecodec, \hyperlink{structaom__image}{aom\_image\_t} *img,
126                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in, AvxVideoWriter *writer,
127                         \textcolor{keywordtype}{int} test\_decode, \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *dcodec,
128                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen,
129                         \hyperlink{structaom__image}{aom\_image\_t} *ext\_ref) \{
130   \textcolor{keywordtype}{int} got\_pkts = 0;
131   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
132   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
133   \textcolor{keywordtype}{int} got\_data;
134   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ecodec, img, frame\_in, 1, 0);
135   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ecodec, \textcolor{stringliteral}{"Failed to encode frame"});
136 
137   got\_data = 0;
138 
139   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ecodec, &iter)) != NULL) \{
140     got\_pkts = 1;
141 
142     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
143       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
144 
145       \textcolor{keywordflow}{if} (!(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gac7ed4e63a83eb9a31886dc7d584d1fc0}{AOM\_FRAME\_IS\_FRAGMENT})) \{
146         *frame\_out += 1;
147       \}
148 
149       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
150                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
151                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
152         die\_codec(ecodec, \textcolor{stringliteral}{"Failed to write compressed frame"});
153       \}
154       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
155       fflush(stdout);
156       got\_data = 1;
157 
158       \textcolor{comment}{// Decode 1 frame.}
159       \textcolor{keywordflow}{if} (test\_decode) \{
160         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(dcodec, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
161                              (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL))
162           die\_codec(dcodec, \textcolor{stringliteral}{"Failed to decode frame."});
163 
164         \textcolor{comment}{// Copy out first decoded frame, and use it as reference later.}
165         \textcolor{keywordflow}{if} (*frame\_out == 1 && ext\_ref != NULL)
166           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(dcodec, 
      \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE}, ext\_ref))
167             die\_codec(dcodec, \textcolor{stringliteral}{"Failed to get decoder new frame"});
168       \}
169     \}
170   \}
171 
172   \textcolor{comment}{// Mismatch checking}
173   \textcolor{keywordflow}{if} (got\_data && test\_decode) \{
174     testing\_decode(ecodec, dcodec, *frame\_out, mismatch\_seen);
175   \}
176 
177   \textcolor{keywordflow}{return} got\_pkts;
178 \}
179 
180 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
181   FILE *infile = NULL;
182   \textcolor{comment}{// Encoder}
183   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} ecodec;
184   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
185   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in = 0;
186   \hyperlink{structaom__image}{aom\_image\_t} raw;
187   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
188   \hyperlink{structaom__image}{aom\_image\_t} ext\_ref;
189   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
190   AvxVideoInfo info;
191   AvxVideoWriter *writer = NULL;
192   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
193   \textcolor{keywordtype}{int} flags = 0;
194   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
195   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} raw\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
196   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
197 
198   \textcolor{comment}{// Test encoder/decoder mismatch.}
199   \textcolor{keywordtype}{int} test\_decode = 1;
200   \textcolor{comment}{// Decoder}
201   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} dcodec;
202   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out = 0;
203 
204   \textcolor{comment}{// The frame number to set reference frame on}
205   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} update\_frame\_num = 0;
206   \textcolor{keywordtype}{int} mismatch\_seen = 0;
207 
208   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
209   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 500;
210 
211   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
212   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
213   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
214   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
215   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
216   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *update\_frame\_num\_arg = NULL;
217   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit = 0;
218   exec\_name = argv[0];
219 
220   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
221   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
222   memset(&ecodec, 0, \textcolor{keyword}{sizeof}(ecodec));
223   memset(&cfg, 0, \textcolor{keyword}{sizeof}(cfg));
224   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
225 
226   \textcolor{keywordflow}{if} (argc < 7) die(\textcolor{stringliteral}{"Invalid number of arguments"});
227 
228   codec\_arg = argv[1];
229   width\_arg = argv[2];
230   height\_arg = argv[3];
231   infile\_arg = argv[4];
232   outfile\_arg = argv[5];
233   update\_frame\_num\_arg = argv[6];
234 
235   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
236   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
237 
238   update\_frame\_num = (\textcolor{keywordtype}{unsigned} int)strtoul(update\_frame\_num\_arg, NULL, 0);
239   \textcolor{comment}{// In AV1, the reference buffers (cm->buffer\_pool->frame\_bufs[i].buf) are}
240   \textcolor{comment}{// allocated while calling aom\_codec\_encode(), thus, setting reference for}
241   \textcolor{comment}{// 1st frame isn't supported.}
242   \textcolor{keywordflow}{if} (update\_frame\_num <= 1) \{
243     die(\textcolor{stringliteral}{"Couldn't parse frame number '%s'\(\backslash\)n"}, update\_frame\_num\_arg);
244   \}
245 
246   \textcolor{keywordflow}{if} (argc > 7) \{
247     limit = (\textcolor{keywordtype}{unsigned} int)strtoul(argv[7], NULL, 0);
248     \textcolor{keywordflow}{if} (update\_frame\_num > limit)
249       die(\textcolor{stringliteral}{"Update frame number couldn't larger than limit\(\backslash\)n"});
250   \}
251 
252   info.codec\_fourcc = encoder->fourcc;
253   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
254   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
255   info.time\_base.numerator = 1;
256   info.time\_base.denominator = fps;
257 
258   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0) \{
259     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
260   \}
261 
262   \textcolor{comment}{// In this test, the bit depth of input video is 8-bit, and the input format}
263   \textcolor{comment}{// is AOM\_IMG\_FMT\_I420.}
264   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, raw\_fmt, info.frame\_width, info.frame\_height, 32)) \{
265     die(\textcolor{stringliteral}{"Failed to allocate image."});
266   \}
267 
268   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
269   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
270   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&ext\_ref, ref\_fmt, info.frame\_width,
271                                  info.frame\_height, 32, 8,
272                                  AOM\_BORDER\_IN\_PIXELS)) \{
273     die(\textcolor{stringliteral}{"Failed to allocate image."});
274   \}
275 
276   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
277 
278   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
279   \textcolor{keywordflow}{if} (res) die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to get default codec config."});
280 
281   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
282   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
283   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
284   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
285   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
286   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 3;
287   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
288 
289   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
290                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
291                : 0;
292 
293   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
294   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
295 
296   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
297     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
298 
299   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&ecodec, encoder->codec\_interface(), &cfg, flags))
300     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to initialize encoder"});
301 
302   \textcolor{comment}{// Disable alt\_ref.}
303   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
304     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set enable auto alt ref"});
305 
306   \textcolor{keywordflow}{if} (test\_decode) \{
307     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(codec\_arg);
308     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&dcodec, decoder->codec\_interface(), NULL, 0))
309       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to initialize decoder."});
310   \}
311 
312   \textcolor{comment}{// Encode frames.}
313   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
314     \textcolor{keywordflow}{if} (limit && frame\_in >= limit) \textcolor{keywordflow}{break};
315     \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
316 
317     \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
318       \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
319       \textcolor{keywordtype}{int} input\_shift = 0;
320       \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
321         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw\_fmt | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
322                       info.frame\_width, info.frame\_height, 32);
323         allocated\_raw\_shift = 1;
324       \}
325       aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
326       frame\_to\_encode = &raw\_shift;
327     \} \textcolor{keywordflow}{else} \{
328       frame\_to\_encode = &raw;
329     \}
330 
331     \textcolor{keywordflow}{if} (update\_frame\_num > 1 && frame\_out + 1 == update\_frame\_num) \{
332       \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
333       ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
334       ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 0;
335       ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = ext\_ref;
336       \textcolor{comment}{// Set reference frame in encoder.}
337       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
338         die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set encoder reference frame"});
339       printf(\textcolor{stringliteral}{" <SET\_REF>"});
340 
341       \textcolor{comment}{// If set\_reference in decoder is commented out, the enc/dec mismatch}
342       \textcolor{comment}{// would be seen.}
343       \textcolor{keywordflow}{if} (test\_decode) \{
344         ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
345         \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&dcodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
346           die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to set decoder reference frame"});
347       \}
348     \}
349 
350     encode\_frame(&ecodec, frame\_to\_encode, frame\_in, writer, test\_decode,
351                  &dcodec, &frame\_out, &mismatch\_seen, &ext\_ref);
352     frame\_in++;
353     \textcolor{keywordflow}{if} (mismatch\_seen) \textcolor{keywordflow}{break};
354   \}
355 
356   \textcolor{comment}{// Flush encoder.}
357   \textcolor{keywordflow}{if} (!mismatch\_seen)
358     \textcolor{keywordflow}{while} (encode\_frame(&ecodec, NULL, frame\_in, writer, test\_decode, &dcodec,
359                         &frame\_out, &mismatch\_seen, NULL)) \{
360     \}
361 
362   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
363   fclose(infile);
364   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_out);
365 
366   \textcolor{keywordflow}{if} (test\_decode) \{
367     \textcolor{keywordflow}{if} (!mismatch\_seen)
368       printf(\textcolor{stringliteral}{"Encoder/decoder results are matching.\(\backslash\)n"});
369     \textcolor{keywordflow}{else}
370       printf(\textcolor{stringliteral}{"Encoder/decoder results are NOT matching.\(\backslash\)n"});
371   \}
372 
373   \textcolor{keywordflow}{if} (test\_decode)
374     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&dcodec))
375       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to destroy decoder"});
376 
377   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
378   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&ext\_ref);
379   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
380   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&ecodec))
381     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to destroy encoder."});
382 
383   aom\_video\_writer\_close(writer);
384 
385   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
386 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_encoder}{}\subsection{lightfield\+\_\+encoder}\label{example_lightfield_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Encoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield encoder.  It builds upon the}
16 \textcolor{comment}{// twopass\_encoder.c example. It takes an input file in YV12 format,}
17 \textcolor{comment}{// treating it as a planar lightfield instead of a video. The img\_width}
18 \textcolor{comment}{// and img\_height arguments are the dimensions of the lightfield images,}
19 \textcolor{comment}{// while the lf\_width and lf\_height arguments are the number of}
20 \textcolor{comment}{// lightfield images in each dimension. The lf\_blocksize determines the}
21 \textcolor{comment}{// number of reference images used for MCP. For example, 5 means that there}
22 \textcolor{comment}{// is a reference image for every 5x5 lightfield image block. All images}
23 \textcolor{comment}{// within a block will use the center image in that block as the reference}
24 \textcolor{comment}{// image for MCP.}
25 \textcolor{comment}{// Run "make test" to download lightfield test data: vase10x10.yuv.}
26 \textcolor{comment}{// Run lightfield encoder to encode whole lightfield:}
27 \textcolor{comment}{// examples/lightfield\_encoder 1024 1024 vase10x10.yuv vase10x10.ivf 10 10 5}
28 
29 \textcolor{comment}{// Note: In bitstream.c and encoder.c, define EXT\_TILE\_DEBUG as 1 will print}
30 \textcolor{comment}{// out the uncompressed header and the frame contexts, which can be used to}
31 \textcolor{comment}{// test the bit exactness of the headers and the frame contexts for large scale}
32 \textcolor{comment}{// tile coded frames.}
33 
34 \textcolor{preprocessor}{#include <stdio.h>}
35 \textcolor{preprocessor}{#include <stdlib.h>}
36 \textcolor{preprocessor}{#include <string.h>}
37 
38 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
39 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
40 \textcolor{preprocessor}{#include "av1/common/enums.h"}
41 
42 \textcolor{preprocessor}{#include "common/tools\_common.h"}
43 \textcolor{preprocessor}{#include "common/video\_writer.h"}
44 
45 \textcolor{preprocessor}{#define MAX\_EXTERNAL\_REFERENCES 128}
46 \textcolor{preprocessor}{#define AOM\_BORDER\_IN\_PIXELS 288}
47 
48 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
49 
50 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
51   fprintf(stderr,
52           \textcolor{stringliteral}{"Usage: %s <img\_width> <img\_height> <infile> <outfile> "}
53           \textcolor{stringliteral}{"<lf\_width> <lf\_height> <lf\_blocksize>\(\backslash\)n"},
54           exec\_name);
55   exit(EXIT\_FAILURE);
56 \}
57 
58 \textcolor{keyword}{static} \textcolor{keywordtype}{int} aom\_img\_size\_bytes(\hyperlink{structaom__image}{aom\_image\_t} *img) \{
59   \textcolor{keywordtype}{int} image\_size\_bytes = 0;
60   \textcolor{keywordtype}{int} plane;
61   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
62     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = \hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(img, plane) *
63                   ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 2 : 1);
64     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(img, plane);
65     image\_size\_bytes += w * h;
66   \}
67   \textcolor{keywordflow}{return} image\_size\_bytes;
68 \}
69 
70 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
71                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
72                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
73                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
74   \textcolor{keywordtype}{int} got\_pkts = 0;
75   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
76   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
77   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
78   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
79 
80   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
81     got\_pkts = 1;
82 
83     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
84       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
85       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
86       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
87       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
88       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
89     \}
90   \}
91 
92   \textcolor{keywordflow}{return} got\_pkts;
93 \}
94 
95 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
96                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
97                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
98   \textcolor{keywordtype}{int} got\_pkts = 0;
99   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
100   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
101   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
102   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
103 
104   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
105     got\_pkts = 1;
106     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
107       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
108 
109       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
110                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
111                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
112         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
113       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
114       fflush(stdout);
115     \}
116   \}
117 
118   \textcolor{keywordflow}{return} got\_pkts;
119 \}
120 
121 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_raw\_image(\hyperlink{structaom__image}{aom\_image\_t} **frame\_to\_encode, \hyperlink{structaom__image}{aom\_image\_t} *raw,
122                           \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
123   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
124     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
125     \textcolor{keywordtype}{int} input\_shift = 0;
126     aom\_img\_upshift(raw\_shift, raw, input\_shift);
127     *frame\_to\_encode = raw\_shift;
128   \} \textcolor{keywordflow}{else} \{
129     *frame\_to\_encode = raw;
130   \}
131 \}
132 
133 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
134                              \textcolor{keyword}{const} AvxInterface *encoder,
135                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} lf\_width,
136                              \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
137                              \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
138   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
139   \textcolor{keywordtype}{int} frame\_count = 0;
140   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
141   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
142   \textcolor{keywordtype}{int} bu, bv;
143   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
144   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
145 
146   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
147     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
148   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
149     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
150   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
151     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
152 
153   \textcolor{comment}{// How many reference images we need to encode.}
154   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
155   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
156 
157   printf(\textcolor{stringliteral}{"\(\backslash\)n First pass: "});
158 
159   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
160     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
161       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
162       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
163       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
164       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
165       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
166       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
167 
168       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
169       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
170       u\_block\_size = block\_u\_end - block\_u\_min;
171       v\_block\_size = block\_v\_end - block\_v\_min;
172       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
173       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
174 
175       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
176       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
177             SEEK\_SET);
178       aom\_img\_read(raw, infile);
179       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
180 
181       \textcolor{comment}{// Reference frames can be encoded encoded without tiles.}
182       ++frame\_count;
183       get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
184                       \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
185                           \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
186                           \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
187                           \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
188                           \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF},
189                       &stats);
190     \}
191   \}
192 
193   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
194     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
195 
196   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
197     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
198       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
199       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
200       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
201       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
202       \textcolor{keywordtype}{int} u, v;
203       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
204       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
205       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
206         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
207           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
208           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
209           aom\_img\_read(raw, infile);
210           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
211 
212           ++frame\_count;
213           get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
214                           \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
215                               \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
216                               \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
217                               \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
218                               \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
219                           &stats);
220         \}
221       \}
222     \}
223   \}
224   \textcolor{comment}{// Flush encoder.}
225   \textcolor{comment}{// No ARF, this should not be needed.}
226   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
227   \}
228 
229   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
230 
231   printf(\textcolor{stringliteral}{"\(\backslash\)nFirst pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
232 
233   \textcolor{keywordflow}{return} stats;
234 \}
235 
236 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
237                   \textcolor{keyword}{const} AvxInterface *encoder, \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
238                   \textcolor{keywordtype}{int} lf\_width, \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
239                   \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
240   AvxVideoInfo info = \{ encoder->fourcc,
241                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
242                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
243                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \} \};
244   AvxVideoWriter *writer = NULL;
245   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
246   \textcolor{keywordtype}{int} frame\_count = 0;
247   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
248   \textcolor{keywordtype}{int} bu, bv;
249   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
250   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
251   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
252   \textcolor{keywordtype}{int} reference\_image\_num = 0;
253   \textcolor{keywordtype}{int} i;
254 
255   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
256   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
257 
258   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
259     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
260   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
261     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
262   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
263     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
264   \textcolor{comment}{// Note: The superblock is a sequence parameter and has to be the same for 1}
265   \textcolor{comment}{// sequence. In lightfield application, must choose the superblock size(either}
266   \textcolor{comment}{// 64x64 or 128x128) before the encoding starts. Otherwise, the default is}
267   \textcolor{comment}{// AOM\_SUPERBLOCK\_SIZE\_DYNAMIC, and the superblock size will be set to 64x64}
268   \textcolor{comment}{// internally.}
269   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
270                         \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64}))
271     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set SB size"});
272 
273   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
274   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
275 
276   reference\_image\_num = u\_blocks * v\_blocks;
277   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
278   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
279   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
280   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \{
281     \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[i], ref\_fmt, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
282                                    cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 32, 8, AOM\_BORDER\_IN\_PIXELS)) \{
283       die(\textcolor{stringliteral}{"Failed to allocate image."});
284     \}
285   \}
286 
287   printf(\textcolor{stringliteral}{"\(\backslash\)n Second pass: "});
288 
289   \textcolor{comment}{// Encode reference images first.}
290   printf(\textcolor{stringliteral}{"Encoding Reference Images\(\backslash\)n"});
291   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
292     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
293       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
294       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
295       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
296       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
297       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
298       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
299 
300       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
301       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
302       u\_block\_size = block\_u\_end - block\_u\_min;
303       v\_block\_size = block\_v\_end - block\_v\_min;
304       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
305       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
306 
307       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
308       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
309             SEEK\_SET);
310       aom\_img\_read(raw, infile);
311 
312       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
313 
314       \textcolor{comment}{// Reference frames may be encoded without tiles.}
315       ++frame\_count;
316       printf(\textcolor{stringliteral}{"Encoding reference image %d of %d\(\backslash\)n"}, bv * u\_blocks + bu,
317              u\_blocks * v\_blocks);
318       encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
319                    \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
320                        \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
321                        \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
322                        \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
323                        \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
324                    writer);
325 
326       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
327                             &reference\_images[frame\_count - 1]))
328         die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoder reference frame"});
329     \}
330   \}
331 
332   cfg->\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 1;
333   \textcolor{comment}{// Fixed q encoding for camera frames.}
334   cfg->\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
335   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, cfg))
336     die\_codec(&codec, \textcolor{stringliteral}{"Failed to configure encoder"});
337 
338   \textcolor{comment}{// The fixed q value used in encoding.}
339   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 36))
340     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
341   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
342     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
343   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af341538631ffe2ac2b562c8b5336a10a}{AV1E\_SET\_SINGLE\_TILE\_DECODING}
      , 1))
344     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn on single tile decoding"});
345   \textcolor{comment}{// Set tile\_columns and tile\_rows to MAX values, which guarantees the tile}
346   \textcolor{comment}{// size of 64 x 64 pixels(i.e. 1 SB) for <= 4k resolution.}
347   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 6))
348     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile width"});
349   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS}, 6))
350     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile height"});
351 
352   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
353     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
354       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
355       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
356       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
357       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
358       \textcolor{keywordtype}{int} u, v;
359       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
360       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
361       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
362         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
363           \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
364           ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
365           ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
366           ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[bv * u\_blocks + bu];
367           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
368             die\_codec(&codec, \textcolor{stringliteral}{"Failed to set reference frame"});
369 
370           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
371           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
372           aom\_img\_read(raw, infile);
373           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
374 
375           ++frame\_count;
376           printf(\textcolor{stringliteral}{"Encoding image %d of %d\(\backslash\)n"},
377                  frame\_count - (u\_blocks * v\_blocks), lf\_width * lf\_height);
378           encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
379                        \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
380                            \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
381                            \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
382                            \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
383                            \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
384                        writer);
385         \}
386       \}
387     \}
388   \}
389 
390   \textcolor{comment}{// Flush encoder.}
391   \textcolor{comment}{// No ARF, this should not be needed.}
392   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
393   \}
394 
395   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
396 
397   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
398   aom\_video\_writer\_close(writer);
399 
400   printf(\textcolor{stringliteral}{"\(\backslash\)nSecond pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
401 \}
402 
403 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
404   FILE *infile = NULL;
405   \textcolor{keywordtype}{int} w, h;
406   \textcolor{comment}{// The number of lightfield images in the u and v dimensions.}
407   \textcolor{keywordtype}{int} lf\_width, lf\_height;
408   \textcolor{comment}{// Defines how many images refer to the same reference image for MCP.}
409   \textcolor{comment}{// lf\_blocksize X lf\_blocksize images will all use the reference image}
410   \textcolor{comment}{// in the middle of the block of images.}
411   \textcolor{keywordtype}{int} lf\_blocksize;
412   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
413   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
414   \hyperlink{structaom__image}{aom\_image\_t} raw;
415   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
416   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
417   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
418   \textcolor{keywordtype}{int} flags = 0;
419 
420   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
421   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
422   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s}
423   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[1];
424   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[2];
425   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[3];
426   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[4];
427   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_width\_arg = argv[5];
428   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_height\_arg = argv[6];
429   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *lf\_blocksize\_arg = argv[7];
430   exec\_name = argv[0];
431 
432   \textcolor{keywordflow}{if} (argc < 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
433 
434   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
435   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
436 
437   w = (int)strtol(width\_arg, NULL, 0);
438   h = (int)strtol(height\_arg, NULL, 0);
439   lf\_width = (int)strtol(lf\_width\_arg, NULL, 0);
440   lf\_height = (int)strtol(lf\_height\_arg, NULL, 0);
441   lf\_blocksize = (int)strtol(lf\_blocksize\_arg, NULL, 0);
442   lf\_blocksize = lf\_blocksize < lf\_width ? lf\_blocksize : lf\_width;
443   lf\_blocksize = lf\_blocksize < lf\_height ? lf\_blocksize : lf\_height;
444 
445   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
446     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
447   \textcolor{keywordflow}{if} (lf\_width <= 0 || lf\_height <= 0)
448     die(\textcolor{stringliteral}{"Invalid lf\_width and/or lf\_height: %dx%d"}, lf\_width, lf\_height);
449   \textcolor{keywordflow}{if} (lf\_blocksize <= 0) die(\textcolor{stringliteral}{"Invalid lf\_blocksize: %d"}, lf\_blocksize);
450 
451   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 32)) \{
452     die(\textcolor{stringliteral}{"Failed to allocate image."});
453   \}
454   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
455     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
456     \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}, w, h,
457                   32);
458   \}
459 
460   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
461 
462   \textcolor{comment}{// Configuration}
463   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
464   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
465 
466   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
467   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
468   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
469   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
470   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
471   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;  \textcolor{comment}{// This is required.}
472   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;    \textcolor{comment}{// need to set this since default is 19.}
473   cfg.\hyperlink{structaom__codec__enc__cfg_a3c1ea7f3ea90b9b8eab4c3f266ffacdc}{kf\_mode} = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
474   cfg.\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 0;  \textcolor{comment}{// Only set it to 1 for camera frame encoding.}
475   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
476   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
477                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
478                : 0;
479 
480   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
481     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
482 
483   \textcolor{comment}{// Pass 0}
484   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
485   stats = pass0(&raw, infile, encoder, &cfg, lf\_width, lf\_height, lf\_blocksize,
486                 flags, &raw\_shift);
487 
488   \textcolor{comment}{// Pass 1}
489   rewind(infile);
490   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
491   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
492   pass1(&raw, infile, outfile\_arg, encoder, &cfg, lf\_width, lf\_height,
493         lf\_blocksize, flags, &raw\_shift);
494   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
495 
496   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
497   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
498   fclose(infile);
499 
500   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
501 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_tile_list_decoder}{}\subsection{lightfield\+\_\+tile\+\_\+list\+\_\+decoder}\label{example_lightfield_tile_list_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Tile List Decoder}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield tile list decoder example. It takes an input file that}
16 \textcolor{comment}{// contains the anchor frames that are references of the coded tiles, the camera}
17 \textcolor{comment}{// frame header, and tile list OBUs that include the tile information and the}
18 \textcolor{comment}{// compressed tile data. This input file is reconstructed from the encoded}
19 \textcolor{comment}{// lightfield ivf file, and is decodable by AV1 decoder. num\_references is}
20 \textcolor{comment}{// the number of anchor frames coded at the beginning of the light field file.}
21 \textcolor{comment}{// num\_tile\_lists is the number of tile lists need to be decoded.}
22 \textcolor{comment}{// Run lightfield tile list decoder to decode an AV1 tile list file:}
23 \textcolor{comment}{// examples/lightfield\_tile\_list\_decoder vase\_tile\_list.ivf vase\_tile\_list.yuv}
24 \textcolor{comment}{// 4 2}
25 
26 \textcolor{preprocessor}{#include <stdio.h>}
27 \textcolor{preprocessor}{#include <stdlib.h>}
28 \textcolor{preprocessor}{#include <string.h>}
29 \textcolor{preprocessor}{#include <assert.h>}
30 
31 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
32 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
33 \textcolor{preprocessor}{#include "common/tools\_common.h"}
34 \textcolor{preprocessor}{#include "common/video\_reader.h"}
35 
36 \textcolor{preprocessor}{#define MAX\_EXTERNAL\_REFERENCES 128}
37 \textcolor{preprocessor}{#define AOM\_BORDER\_IN\_PIXELS 288}
38 
39 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
40 
41 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
42   fprintf(stderr,
43           \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <num\_tile\_lists>\(\backslash\)n"},
44           exec\_name);
45   exit(EXIT\_FAILURE);
46 \}
47 
48 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
49   FILE *outfile = NULL;
50   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
51   AvxVideoReader *reader = NULL;
52   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
53   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
54   \textcolor{keywordtype}{int} width, height;
55   \textcolor{keywordtype}{int} num\_references;
56   \textcolor{keywordtype}{int} num\_tile\_lists;
57   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
58   \textcolor{keywordtype}{size\_t} frame\_size = 0;
59   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
60   \textcolor{keywordtype}{int} i, j, n;
61 
62   exec\_name = argv[0];
63 
64   \textcolor{keywordflow}{if} (argc != 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
65 
66   reader = aom\_video\_reader\_open(argv[1]);
67   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
68 
69   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
70     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
71 
72   num\_references = (int)strtol(argv[3], NULL, 0);
73   num\_tile\_lists = (int)strtol(argv[4], NULL, 0);
74 
75   info = aom\_video\_reader\_get\_info(reader);
76   width = info->frame\_width;
77   height = info->frame\_height;
78 
79   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
80   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
81   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
82 
83   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
84     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
85 
86   \textcolor{comment}{// Decode anchor frames.}
87   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
88 
89   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
90     aom\_video\_reader\_read\_frame(reader);
91     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
92     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
93       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
94 
95     \textcolor{keywordflow}{if} (i == 0) \{
96       \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
97       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
98         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
99 
100       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
101       \textcolor{comment}{// border so that it can be used as a reference.}
102       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
103         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_BORDER\_IN\_PIXELS;
104         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt, width,
105                                        height, 32, 8, border)) \{
106           die(\textcolor{stringliteral}{"Failed to allocate references."});
107         \}
108       \}
109     \}
110 
111     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
112                           &reference\_images[i]))
113       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
114 
115     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
116     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
117     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
118       \textcolor{keywordtype}{char} name[1024];
119       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
120       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
121       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
122       aom\_img\_write(img, ref\_file);
123       fclose(ref\_file);
124     \}
125   \}
126 
127   \textcolor{comment}{// Decode the lightfield.}
128   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
129 
130   \textcolor{comment}{// Set external references.}
131   \hyperlink{structav1__ext__ref__frame}{av1\_ext\_ref\_frame\_t} set\_ext\_ref = \{ &reference\_images[0], num\_references \};
132   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badfbe6c1ebe4039bfef4d2cfd98755add}{AV1D\_SET\_EXT\_REF\_PTR}, &set\_ext\_ref);
133 
134   \textcolor{comment}{// Must decode the camera frame header first.}
135   aom\_video\_reader\_read\_frame(reader);
136   frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
137   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
138     die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the frame."});
139 
140   \textcolor{comment}{// Decode tile lists one by one.}
141   \textcolor{keywordflow}{for} (n = 0; n < num\_tile\_lists; n++) \{
142     aom\_video\_reader\_read\_frame(reader);
143     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
144 
145     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
146       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the tile list."});
147     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
148     \hyperlink{structaom__image}{aom\_image\_t} *img;
149     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)))
150       fwrite(img->\hyperlink{structaom__image_a7c367f3227d5876ce9e5c198a01c2028}{img\_data}, 1, img->\hyperlink{structaom__image_af0f6c220bf000d1c488075c19d889290}{sz}, outfile);
151   \}
152 
153   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
154   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
155   aom\_video\_reader\_close(reader);
156   fclose(outfile);
157 
158   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
159 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_decoder}{}\subsection{lightfield\+\_\+decoder}\label{example_lightfield_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Decoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield decoder. It builds upon the}
16 \textcolor{comment}{// simple\_decoder.c example.  It takes an input file containing the compressed}
17 \textcolor{comment}{// data (in ivf format), treating it as a lightfield instead of a video.}
18 \textcolor{comment}{// After running the lightfield encoder, run lightfield decoder to decode a}
19 \textcolor{comment}{// batch of tiles:}
20 \textcolor{comment}{// examples/lightfield\_decoder vase10x10.ivf vase\_reference.yuv 4}
21 
22 \textcolor{preprocessor}{#include <stdio.h>}
23 \textcolor{preprocessor}{#include <stdlib.h>}
24 \textcolor{preprocessor}{#include <string.h>}
25 
26 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
27 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
28 \textcolor{preprocessor}{#include "common/tools\_common.h"}
29 \textcolor{preprocessor}{#include "common/video\_reader.h"}
30 
31 \textcolor{preprocessor}{#define MAX\_EXTERNAL\_REFERENCES 128}
32 \textcolor{preprocessor}{#define AOM\_BORDER\_IN\_PIXELS 288}
33 
34 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
35 
36 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
37   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references>\(\backslash\)n"}, exec\_name);
38   exit(EXIT\_FAILURE);
39 \}
40 
41 \textcolor{comment}{// Tile list entry provided by the application}
42 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
43   \textcolor{keywordtype}{int} image\_idx;
44   \textcolor{keywordtype}{int} reference\_idx;
45   \textcolor{keywordtype}{int} tile\_col;
46   \textcolor{keywordtype}{int} tile\_row;
47 \} TILE\_LIST\_INFO;
48 
49 \textcolor{comment}{// M references: 0 - M-1; N images(including references): 0 - N-1;}
50 \textcolor{comment}{// Note: order the image index incrementally, so that we only go through the}
51 \textcolor{comment}{// bitstream once to construct the tile list.}
52 \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_tile\_lists = 2;
53 \textcolor{keyword}{const} uint16\_t tile\_count\_minus\_1 = 9 - 1;
54 \textcolor{keyword}{const} TILE\_LIST\_INFO tile\_list[2][9] = \{
55   \{ \{ 16, 0, 4, 5 \},
56     \{ 83, 3, 13, 2 \},
57     \{ 57, 2, 2, 6 \},
58     \{ 31, 1, 11, 5 \},
59     \{ 2, 0, 7, 4 \},
60     \{ 77, 3, 9, 9 \},
61     \{ 49, 1, 0, 1 \},
62     \{ 6, 0, 3, 10 \},
63     \{ 63, 2, 5, 8 \} \},
64   \{ \{ 65, 2, 11, 1 \},
65     \{ 42, 1, 3, 7 \},
66     \{ 88, 3, 8, 4 \},
67     \{ 76, 3, 1, 15 \},
68     \{ 1, 0, 2, 2 \},
69     \{ 19, 0, 5, 6 \},
70     \{ 60, 2, 4, 0 \},
71     \{ 25, 1, 11, 15 \},
72     \{ 50, 2, 5, 4 \} \},
73 \};
74 
75 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
76   FILE *outfile = NULL;
77   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
78   AvxVideoReader *reader = NULL;
79   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
80   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
81   \textcolor{keywordtype}{int} num\_references;
82   \textcolor{keywordtype}{int} width, height;
83   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
84   \textcolor{keywordtype}{size\_t} frame\_size = 0;
85   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
86   \textcolor{keywordtype}{int} n, i, j;
87   exec\_name = argv[0];
88 
89   \textcolor{keywordflow}{if} (argc != 4) die(\textcolor{stringliteral}{"Invalid number of arguments."});
90 
91   reader = aom\_video\_reader\_open(argv[1]);
92   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
93 
94   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
95     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
96 
97   num\_references = (int)strtol(argv[3], NULL, 0);
98 
99   info = aom\_video\_reader\_get\_info(reader);
100   width = info->frame\_width;
101   height = info->frame\_height;
102 
103   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
104   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
105   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
106 
107   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
108     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
109 
110   \textcolor{comment}{// Decode anchor frames.}
111   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
112   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
113     aom\_video\_reader\_read\_frame(reader);
114     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
115     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
116       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
117 
118     \textcolor{keywordflow}{if} (i == 0) \{
119       \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
120       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
121         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
122 
123       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
124       \textcolor{comment}{// border so that it can be used as a reference.}
125       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
126         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_BORDER\_IN\_PIXELS;
127         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt, width,
128                                        height, 32, 8, border)) \{
129           die(\textcolor{stringliteral}{"Failed to allocate references."});
130         \}
131       \}
132     \}
133 
134     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
135                           &reference\_images[i]))
136       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
137 
138     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
139     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
140     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
141       \textcolor{keywordtype}{char} name[1024];
142       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
143       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
144       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
145       aom\_img\_write(img, ref\_file);
146       fclose(ref\_file);
147     \}
148   \}
149 
150   FILE *infile = aom\_video\_reader\_get\_file(reader);
151   \textcolor{comment}{// Record the offset of the first camera image.}
152   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
153 
154   \textcolor{comment}{// Process 1 tile.}
155   \textcolor{keywordflow}{for} (n = 0; n < num\_tile\_lists; n++) \{
156     \textcolor{keywordflow}{for} (i = 0; i <= tile\_count\_minus\_1; i++) \{
157       \textcolor{keywordtype}{int} image\_idx = tile\_list[n][i].image\_idx;
158       \textcolor{keywordtype}{int} ref\_idx = tile\_list[n][i].reference\_idx;
159       \textcolor{keywordtype}{int} tc = tile\_list[n][i].tile\_col;
160       \textcolor{keywordtype}{int} tr = tile\_list[n][i].tile\_row;
161       \textcolor{keywordtype}{int} frame\_cnt = -1;
162 
163       \textcolor{comment}{// Seek to the first camera image.}
164       fseeko(infile, camera\_frame\_pos, SEEK\_SET);
165 
166       \textcolor{comment}{// Read out the camera image}
167       \textcolor{keywordflow}{while} (frame\_cnt != image\_idx) \{
168         aom\_video\_reader\_read\_frame(reader);
169         frame\_cnt++;
170       \}
171 
172       frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
173 
174       \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
175       \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
176       \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
177       \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
178 
179       \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
180       ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
181       ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
182       ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[ref\_idx];
183       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref)) \{
184         die\_codec(&codec, \textcolor{stringliteral}{"Failed to set reference frame."});
185       \}
186 
187       \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
188           \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL);
189       \textcolor{keywordflow}{if} (aom\_status) die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode tile."});
190 
191       \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
192       \hyperlink{structaom__image}{aom\_image\_t} *img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter);
193       aom\_img\_write(img, outfile);
194     \}
195   \}
196 
197   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
198   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
199   aom\_video\_reader\_close(reader);
200   fclose(outfile);
201 
202   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
203 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_bitstream_parsing}{}\subsection{lightfield\+\_\+bitstream\+\_\+parsing}\label{example_lightfield_bitstream_parsing}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Bitstream Parsing}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield bitstream parsing example. It takes an input file}
16 \textcolor{comment}{// containing the whole compressed lightfield bitstream(ivf file), and parses it}
17 \textcolor{comment}{// and constructs and outputs a new bitstream that can be decoded by an AV1}
18 \textcolor{comment}{// decoder. The output bitstream contains reference frames(i.e. anchor frames),}
19 \textcolor{comment}{// camera frame header, and tile list OBUs. num\_references is the number of}
20 \textcolor{comment}{// anchor frames coded at the beginning of the light field file.}
21 \textcolor{comment}{// After running the lightfield encoder, run lightfield bitstream parsing:}
22 \textcolor{comment}{// examples/lightfield\_bitstream\_parsing vase10x10.ivf vase\_tile\_list.ivf 4}
23 
24 \textcolor{preprocessor}{#include <stdio.h>}
25 \textcolor{preprocessor}{#include <stdlib.h>}
26 \textcolor{preprocessor}{#include <string.h>}
27 
28 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
29 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
30 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
31 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
32 \textcolor{preprocessor}{#include "aom\_dsp/bitwriter\_buffer.h"}
33 \textcolor{preprocessor}{#include "common/tools\_common.h"}
34 \textcolor{preprocessor}{#include "common/video\_reader.h"}
35 \textcolor{preprocessor}{#include "common/video\_writer.h"}
36 
37 \textcolor{preprocessor}{#define MAX\_TILES 512}
38 
39 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
40 
41 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
42   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> \(\backslash\)n"},
43           exec\_name);
44   exit(EXIT\_FAILURE);
45 \}
46 
47 \textcolor{preprocessor}{#define ALIGN\_POWER\_OF\_TWO(value, n) \(\backslash\)}
48 \textcolor{preprocessor}{  (((value) + ((1 << (n)) - 1)) & ~((1 << (n)) - 1))}
49 
50 \textcolor{comment}{// SB size: 64x64}
51 \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles\_minus\_1 = 512 / 64 - 1;
52 \textcolor{keyword}{const} uint8\_t output\_frame\_height\_in\_tiles\_minus\_1 = 512 / 64 - 1;
53 
54 \textcolor{comment}{// Spec:}
55 \textcolor{comment}{// typedef struct \{}
56 \textcolor{comment}{//   uint8\_t anchor\_frame\_idx;}
57 \textcolor{comment}{//   uint8\_t tile\_row;}
58 \textcolor{comment}{//   uint8\_t tile\_col;}
59 \textcolor{comment}{//   uint16\_t coded\_tile\_data\_size\_minus\_1;}
60 \textcolor{comment}{//   uint8\_t *coded\_tile\_data;}
61 \textcolor{comment}{// \} TILE\_LIST\_ENTRY;}
62 
63 \textcolor{comment}{// Tile list entry provided by the application}
64 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
65   \textcolor{keywordtype}{int} image\_idx;
66   \textcolor{keywordtype}{int} reference\_idx;
67   \textcolor{keywordtype}{int} tile\_col;
68   \textcolor{keywordtype}{int} tile\_row;
69 \} TILE\_LIST\_INFO;
70 
71 \textcolor{comment}{// M references: 0 - M-1; N images(including references): 0 - N-1;}
72 \textcolor{comment}{// Note: order the image index incrementally, so that we only go through the}
73 \textcolor{comment}{// bitstream once to construct the tile list.}
74 \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_tile\_lists = 2;
75 \textcolor{keyword}{const} uint16\_t tile\_count\_minus\_1 = 9 - 1;
76 \textcolor{keyword}{const} TILE\_LIST\_INFO tile\_list[2][9] = \{
77   \{ \{ 16, 0, 4, 5 \},
78     \{ 83, 3, 13, 2 \},
79     \{ 57, 2, 2, 6 \},
80     \{ 31, 1, 11, 5 \},
81     \{ 2, 0, 7, 4 \},
82     \{ 77, 3, 9, 9 \},
83     \{ 49, 1, 0, 1 \},
84     \{ 6, 0, 3, 10 \},
85     \{ 63, 2, 5, 8 \} \},
86   \{ \{ 65, 2, 11, 1 \},
87     \{ 42, 1, 3, 7 \},
88     \{ 88, 3, 8, 4 \},
89     \{ 76, 3, 1, 15 \},
90     \{ 1, 0, 2, 2 \},
91     \{ 19, 0, 5, 6 \},
92     \{ 60, 2, 4, 0 \},
93     \{ 25, 1, 11, 15 \},
94     \{ 50, 2, 5, 4 \} \},
95 \};
96 
97 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_image\_bps(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} fmt) \{
98   \textcolor{keywordflow}{switch} (fmt) \{
99     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} 12;
100     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} 16;
101     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} 24;
102     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} 24;
103     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} 32;
104     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} 48;
105     \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Invalid image format"});
106   \}
107 \}
108 
109 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
110   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
111   AvxVideoReader *reader = NULL;
112   AvxVideoWriter *writer = NULL;
113   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
114   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
115   \textcolor{keywordtype}{int} num\_references;
116   \textcolor{keywordtype}{int} n, i;
117   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts;
118 
119   exec\_name = argv[0];
120   \textcolor{keywordflow}{if} (argc != 4) die(\textcolor{stringliteral}{"Invalid number of arguments."});
121 
122   reader = aom\_video\_reader\_open(argv[1]);
123   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
124 
125   num\_references = (int)strtol(argv[3], NULL, 0);
126   info = aom\_video\_reader\_get\_info(reader);
127 
128   \textcolor{comment}{// The writer to write out ivf file in tile list OBU, which can be decoded by}
129   \textcolor{comment}{// AV1 decoder.}
130   writer = aom\_video\_writer\_open(argv[2], kContainerIVF, info);
131   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, argv[2]);
132 
133   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
134   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
135   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
136 
137   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
138     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
139 
140   \textcolor{comment}{// Decode anchor frames.}
141   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
142 
143   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
144     aom\_video\_reader\_read\_frame(reader);
145 
146     \textcolor{keywordtype}{size\_t} frame\_size = 0;
147     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
148         aom\_video\_reader\_get\_frame(reader, &frame\_size);
149     pts = (\hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t})aom\_video\_reader\_get\_frame\_pts(reader);
150 
151     \textcolor{comment}{// Copy references bitstream directly.}
152     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame, frame\_size, pts))
153       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed anchor frame."});
154 
155     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
156       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
157   \}
158 
159   \textcolor{comment}{// Decode camera frames.}
160   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
161   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
162 
163   FILE *infile = aom\_video\_reader\_get\_file(reader);
164   \textcolor{comment}{// Record the offset of the first camera image.}
165   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
166 
167   \textcolor{comment}{// Read out the first camera frame.}
168   aom\_video\_reader\_read\_frame(reader);
169 
170   \textcolor{comment}{// Copy first camera frame for getting camera frame header. This is done}
171   \textcolor{comment}{// only once.}
172   \{
173     \textcolor{keywordtype}{size\_t} frame\_size = 0;
174     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
175         aom\_video\_reader\_get\_frame(reader, &frame\_size);
176     pts = (\hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t})aom\_video\_reader\_get\_frame\_pts(reader);
177     \hyperlink{structaom__tile__data}{aom\_tile\_data} frame\_header\_info = \{ 0, NULL, 0 \};
178 
179     \textcolor{comment}{// Need to decode frame header to get camera frame header info. So, here}
180     \textcolor{comment}{// decoding 1 tile is enough.}
181     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, 0);
182     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, AV1\_SET\_DECODE\_TILE\_COL, 0);
183 
184     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
185         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL);
186     \textcolor{keywordflow}{if} (aom\_status) die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode tile."});
187 
188     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baed16ed4514ea1bd2847e607ca880b246}{AV1D\_GET\_FRAME\_HEADER\_INFO}, &
      frame\_header\_info);
189 
190     \textcolor{keywordtype}{size\_t} obu\_size\_offset =
191         (uint8\_t *)frame\_header\_info.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data} - frame;
192     \textcolor{keywordtype}{size\_t} length\_field\_size = frame\_header\_info.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
193     \textcolor{comment}{// Remove ext-tile tile info.}
194     uint32\_t frame\_header\_size = (uint32\_t)frame\_header\_info.\hyperlink{structaom__tile__data_a936851e515bcea0af38d2d091f5adf65}{extra\_size} - 1;
195     \textcolor{keywordtype}{size\_t} bytes\_to\_copy =
196         obu\_size\_offset + length\_field\_size + frame\_header\_size;
197 
198     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame\_hdr\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(bytes\_to\_copy);
199     \textcolor{keywordflow}{if} (frame\_hdr\_buf == NULL)
200       die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate frame header buffer."});
201 
202     memcpy(frame\_hdr\_buf, frame, bytes\_to\_copy);
203 
204     \textcolor{comment}{// Update frame header OBU size.}
205     \textcolor{keywordtype}{size\_t} bytes\_written = 0;
206     \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(
207             frame\_header\_size, length\_field\_size, length\_field\_size,
208             frame\_hdr\_buf + obu\_size\_offset, &bytes\_written))
209       die\_codec(&codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
210 
211     \textcolor{comment}{// Copy camera frame header bitstream.}
212     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame\_hdr\_buf, bytes\_to\_copy,
213                                       pts))
214       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed camera frame header."});
215   \}
216 
217   \textcolor{comment}{// Read out the image format.}
218   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
219   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
220     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
221   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bps = get\_image\_bps(ref\_fmt);
222   \textcolor{comment}{// read out the tile size.}
223   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
224   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
225     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the tile size"});
226   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
227   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
228   \textcolor{comment}{// Allocate a buffer to store tile list bitstream.}
229   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} data\_sz = MAX\_TILES * ALIGN\_POWER\_OF\_TWO(tile\_width, 5) *
230                          ALIGN\_POWER\_OF\_TWO(tile\_height, 5) * bps / 8;
231   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(data\_sz);
232   \textcolor{keywordflow}{if} (tl\_buf == NULL) die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate tile list buffer."});
233 
234   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} tl\_pts = pts;
235 
236   \textcolor{comment}{// Process 1 tile list.}
237   \textcolor{keywordflow}{for} (n = 0; n < num\_tile\_lists; n++) \{
238     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl = tl\_buf;
239     \textcolor{keyword}{struct }aom\_write\_bit\_buffer wb = \{ tl, 0 \};
240     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *saved\_obu\_size\_loc = NULL;
241     uint32\_t tile\_list\_obu\_header\_size = 0;
242     uint32\_t tile\_list\_obu\_size = 0;
243 
244     \textcolor{comment}{// Write the tile list OBU header that is 1 byte long.}
245     aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// forbidden bit.}
246     aom\_wb\_write\_literal(&wb, 8, 4);  \textcolor{comment}{// tile list OBU: "1000"}
247     aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// obu\_extension = 0}
248     aom\_wb\_write\_literal(&wb, 1, 1);  \textcolor{comment}{// obu\_has\_size\_field}
249     aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// reserved}
250     tl++;
251     tile\_list\_obu\_header\_size++;
252 
253     \textcolor{comment}{// Write the OBU size using a fixed length\_field\_size of 4 bytes.}
254     saved\_obu\_size\_loc = tl;
255     \textcolor{comment}{// aom\_wb\_write\_unsigned\_literal(&wb, data, bits) requires that bits <= 32.}
256     aom\_wb\_write\_unsigned\_literal(&wb, 0, 32);
257     tl += 4;
258     tile\_list\_obu\_header\_size += 4;
259 
260     \textcolor{comment}{// write\_tile\_list\_obu()}
261     aom\_wb\_write\_literal(&wb, output\_frame\_width\_in\_tiles\_minus\_1, 8);
262     aom\_wb\_write\_literal(&wb, output\_frame\_height\_in\_tiles\_minus\_1, 8);
263     aom\_wb\_write\_literal(&wb, tile\_count\_minus\_1, 16);
264     tl += 4;
265     tile\_list\_obu\_size += 4;
266 
267     \textcolor{comment}{// Write each tile's data}
268     \textcolor{keywordflow}{for} (i = 0; i <= tile\_count\_minus\_1; i++) \{
269       \hyperlink{structaom__tile__data}{aom\_tile\_data} tile\_data = \{ 0, NULL, 0 \};
270 
271       \textcolor{keywordtype}{int} image\_idx = tile\_list[n][i].image\_idx;
272       \textcolor{keywordtype}{int} ref\_idx = tile\_list[n][i].reference\_idx;
273       \textcolor{keywordtype}{int} tc = tile\_list[n][i].tile\_col;
274       \textcolor{keywordtype}{int} tr = tile\_list[n][i].tile\_row;
275       \textcolor{keywordtype}{int} frame\_cnt = -1;
276 
277       \textcolor{comment}{// Reset bit writer to the right location.}
278       wb.bit\_buffer = tl;
279       wb.bit\_offset = 0;
280 
281       \textcolor{comment}{// Seek to the first camera image.}
282       fseeko(infile, camera\_frame\_pos, SEEK\_SET);
283 
284       \textcolor{comment}{// Read out the camera image}
285       \textcolor{keywordflow}{while} (frame\_cnt != image\_idx) \{
286         aom\_video\_reader\_read\_frame(reader);
287         frame\_cnt++;
288       \}
289 
290       \textcolor{keywordtype}{size\_t} frame\_size = 0;
291       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
292           aom\_video\_reader\_get\_frame(reader, &frame\_size);
293 
294       \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
295       \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
296 
297       \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
298           \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL);
299       \textcolor{keywordflow}{if} (aom\_status) die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode tile."});
300 
301       \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badf1e96275f692bc97ddb4ce2fbdb456e}{AV1D\_GET\_TILE\_DATA}, &tile\_data);
302 
303       \textcolor{comment}{// Copy over tile info.}
304       \textcolor{comment}{//  uint8\_t anchor\_frame\_idx;}
305       \textcolor{comment}{//  uint8\_t tile\_row;}
306       \textcolor{comment}{//  uint8\_t tile\_col;}
307       \textcolor{comment}{//  uint16\_t coded\_tile\_data\_size\_minus\_1;}
308       \textcolor{comment}{//  uint8\_t *coded\_tile\_data;}
309       uint32\_t tile\_info\_bytes = 5;
310       aom\_wb\_write\_literal(&wb, ref\_idx, 8);
311       aom\_wb\_write\_literal(&wb, tr, 8);
312       aom\_wb\_write\_literal(&wb, tc, 8);
313       aom\_wb\_write\_literal(&wb, (\textcolor{keywordtype}{int})tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size} - 1, 16);
314       tl += tile\_info\_bytes;
315 
316       memcpy(tl, (uint8\_t *)tile\_data.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data},
317              tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size});
318       tl += tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
319 
320       tile\_list\_obu\_size +=
321           tile\_info\_bytes + (uint32\_t)tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
322     \}
323 
324     \textcolor{comment}{// Write tile list OBU size.}
325     \textcolor{keywordtype}{size\_t} bytes\_written = 0;
326     \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(tile\_list\_obu\_size, 4, 4, saved\_obu\_size\_loc,
327                                    &bytes\_written))
328       die\_codec(&codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
329 
330     \textcolor{comment}{// Copy the tile list.}
331     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(
332             writer, tl\_buf, tile\_list\_obu\_header\_size + tile\_list\_obu\_size,
333             tl\_pts))
334       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed tile list."});
335 
336     tl\_pts++;
337   \}
338 
339   free(tl\_buf);
340   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
341   aom\_video\_writer\_close(writer);
342   aom\_video\_reader\_close(reader);
343 
344   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
345 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomdec}{}\subsection{aomdec}\label{example_aomdec}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <assert.h>}
13 \textcolor{preprocessor}{#include <stdio.h>}
14 \textcolor{preprocessor}{#include <stdlib.h>}
15 \textcolor{preprocessor}{#include <stdarg.h>}
16 \textcolor{preprocessor}{#include <string.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 
19 \textcolor{preprocessor}{#include "config/aom\_config.h"}
20 
21 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
22 \textcolor{preprocessor}{#if HAVE\_UNISTD\_H}
23 \textcolor{preprocessor}{#include <unistd.h>}  \textcolor{comment}{// NOLINT}
24 \textcolor{preprocessor}{#elif !defined(STDOUT\_FILENO)}
25 \textcolor{preprocessor}{#define STDOUT\_FILENO 1}
26 \textcolor{preprocessor}{#endif}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
30 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
31 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
32 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
33 \textcolor{preprocessor}{#include "common/args.h"}
34 \textcolor{preprocessor}{#include "common/ivfdec.h"}
35 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
36 \textcolor{preprocessor}{#include "common/obudec.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 
39 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
40 \textcolor{preprocessor}{#include "common/webmdec.h"}
41 \textcolor{preprocessor}{#endif}
42 
43 \textcolor{preprocessor}{#include "common/y4menc.h"}
44 
45 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
46 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
47 \textcolor{preprocessor}{#endif}
48 
49 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
50 
51 \textcolor{keyword}{struct }AvxDecInputContext \{
52   \textcolor{keyword}{struct }AvxInputContext *aom\_input\_ctx;
53   \textcolor{keyword}{struct }ObuDecInputContext *obu\_ctx;
54   \textcolor{keyword}{struct }WebmInputContext *webm\_ctx;
55 \};
56 
57 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
58     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
59 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t looparg =
60     ARG\_DEF(NULL, \textcolor{stringliteral}{"loops"}, 1, \textcolor{stringliteral}{"Number of times to decode the file"});
61 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
62 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
63     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Output raw YV12 frames"});
64 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
65     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Output raw I420 frames"});
66 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t flipuvarg =
67     ARG\_DEF(NULL, \textcolor{stringliteral}{"flipuv"}, 0, \textcolor{stringliteral}{"Flip the chroma planes in the output"});
68 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rawvideo =
69     ARG\_DEF(NULL, \textcolor{stringliteral}{"rawvideo"}, 0, \textcolor{stringliteral}{"Output raw YUV frames"});
70 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noblitarg =
71     ARG\_DEF(NULL, \textcolor{stringliteral}{"noblit"}, 0, \textcolor{stringliteral}{"Don't process the decoded frames"});
72 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t progressarg =
73     ARG\_DEF(NULL, \textcolor{stringliteral}{"progress"}, 0, \textcolor{stringliteral}{"Show progress after each frame decodes"});
74 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limitarg =
75     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop decoding after n frames"});
76 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skiparg =
77     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
78 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t postprocarg =
79     ARG\_DEF(NULL, \textcolor{stringliteral}{"postproc"}, 0, \textcolor{stringliteral}{"Postprocess decoded frames"});
80 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t summaryarg =
81     ARG\_DEF(NULL, \textcolor{stringliteral}{"summary"}, 0, \textcolor{stringliteral}{"Show timing summary"});
82 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
83     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output file name pattern (see below)"});
84 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threadsarg =
85     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max threads to use"});
86 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rowmtarg =
87     ARG\_DEF(NULL, \textcolor{stringliteral}{"row-mt"}, 1, \textcolor{stringliteral}{"Enable row based multi-threading"});
88 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
89     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show version string"});
90 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t scalearg =
91     ARG\_DEF(\textcolor{stringliteral}{"S"}, \textcolor{stringliteral}{"scale"}, 0, \textcolor{stringliteral}{"Scale output frames uniformly"});
92 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t continuearg =
93     ARG\_DEF(\textcolor{stringliteral}{"k"}, \textcolor{stringliteral}{"keep-going"}, 0, \textcolor{stringliteral}{"(debug) Continue decoding after error"});
94 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fb\_arg =
95     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-buffers"}, 1, \textcolor{stringliteral}{"Number of frame buffers to use"});
96 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t md5arg =
97     ARG\_DEF(NULL, \textcolor{stringliteral}{"md5"}, 0, \textcolor{stringliteral}{"Compute the MD5 sum of the decoded frame"});
98 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framestatsarg =
99     ARG\_DEF(NULL, \textcolor{stringliteral}{"framestats"}, 1, \textcolor{stringliteral}{"Output per-frame stats (.csv format)"});
100 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outbitdeptharg =
101     ARG\_DEF(NULL, \textcolor{stringliteral}{"output-bit-depth"}, 1, \textcolor{stringliteral}{"Output bit-depth for decoded frames"});
102 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tilem = ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-mode"}, 1,
103                                        \textcolor{stringliteral}{"Tile coding mode "}
104                                        \textcolor{stringliteral}{"(0 for normal tile coding mode)"});
105 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tiler = ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-row"}, 1,
106                                        \textcolor{stringliteral}{"Row index of tile to decode "}
107                                        \textcolor{stringliteral}{"(-1 for all rows)"});
108 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tilec = ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-column"}, 1,
109                                        \textcolor{stringliteral}{"Column index of tile to decode "}
110                                        \textcolor{stringliteral}{"(-1 for all columns)"});
111 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t isannexb =
112     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 0, \textcolor{stringliteral}{"Bitstream is in Annex-B format"});
113 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t oppointarg = ARG\_DEF(
114     NULL, \textcolor{stringliteral}{"oppoint"}, 1, \textcolor{stringliteral}{"Select an operating point of a scalable bitstream"});
115 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outallarg = ARG\_DEF(
116     NULL, \textcolor{stringliteral}{"all-layers"}, 0, \textcolor{stringliteral}{"Output all decoded frames of a scalable bitstream"});
117 
118 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *all\_args[] = \{
119   &help,        &codecarg,       &use\_yv12,    &use\_i420,   &flipuvarg,
120   &rawvideo,    &noblitarg,      &progressarg, &limitarg,   &skiparg,
121   &postprocarg, &summaryarg,     &outputfile,  &threadsarg, &rowmtarg,
122   &verbosearg,  &scalearg,       &fb\_arg,      &md5arg,     &framestatsarg,
123   &continuearg, &outbitdeptharg, &tilem,       &tiler,      &tilec,
124   &isannexb,    &oppointarg,     &outallarg,   NULL
125 \};
126 
127 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
128 \textcolor{keyword}{static} INLINE \textcolor{keywordtype}{int} libyuv\_scale(\hyperlink{structaom__image}{aom\_image\_t} *src, \hyperlink{structaom__image}{aom\_image\_t} *dst,
129                                FilterModeEnum mode) \{
130   \textcolor{keywordflow}{if} (src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
131     assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016});
132     \textcolor{keywordflow}{return} I420Scale\_16(
133         (uint16\_t *)src->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2,
134         (uint16\_t *)src->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_U] / 2,
135         (uint16\_t *)src->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_V] / 2,
136         src->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16\_t *)dst->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
137         dst->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_U],
138         dst->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_U] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_V],
139         dst->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_V] / 2, dst->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
140   \}
141   assert(src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
142   assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
143   \textcolor{keywordflow}{return} I420Scale(src->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
144                    src->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_U],
145                    src->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_V], src->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
146                    src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, dst->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], dst->
      \hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
147                    dst->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_U], dst->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_U],
148                    dst->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_V], dst->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_V], dst->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
149                    dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
150 \}
151 \textcolor{preprocessor}{#endif}
152 
153 \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
154   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> filename\(\backslash\)n\(\backslash\)n"}, exec\_name);
155 
156   \textcolor{keywordflow}{if} (shorthelp) \{
157     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
158     \textcolor{keywordflow}{return};
159   \}
160 
161   fprintf(fout, \textcolor{stringliteral}{"Options:\(\backslash\)n"});
162   arg\_show\_usage(fout, all\_args);
163   fprintf(fout,
164           \textcolor{stringliteral}{"\(\backslash\)nOutput File Patterns:\(\backslash\)n\(\backslash\)n"}
165           \textcolor{stringliteral}{"  The -o argument specifies the name of the file(s) to "}
166           \textcolor{stringliteral}{"write to. If the\(\backslash\)n  argument does not include any escape "}
167           \textcolor{stringliteral}{"characters, the output will be\(\backslash\)n  written to a single file. "}
168           \textcolor{stringliteral}{"Otherwise, the filename will be calculated by\(\backslash\)n  expanding "}
169           \textcolor{stringliteral}{"the following escape characters:\(\backslash\)n"});
170   fprintf(fout,
171           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%w   - Frame width"}
172           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%h   - Frame height"}
173           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%<n> - Frame number, zero padded to <n> places (1..9)"}
174           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n  Pattern arguments are only supported in conjunction "}
175           \textcolor{stringliteral}{"with the --yv12 and\(\backslash\)n  --i420 options. If the -o option is "}
176           \textcolor{stringliteral}{"not specified, the output will be\(\backslash\)n  directed to stdout.\(\backslash\)n"});
177   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded decoders:\(\backslash\)n\(\backslash\)n"});
178 
179   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_aom\_decoder\_count(); ++i) \{
180     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
181     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s\(\backslash\)n"}, decoder->name,
182             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
183   \}
184 \}
185 
186 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
187   show\_help(stderr, 1);
188   exit(EXIT\_FAILURE);
189 \}
190 
191 \textcolor{keyword}{static} \textcolor{keywordtype}{int} raw\_read\_frame(FILE *infile, uint8\_t **buffer, \textcolor{keywordtype}{size\_t} *bytes\_read,
192                           \textcolor{keywordtype}{size\_t} *buffer\_size) \{
193   \textcolor{keywordtype}{char} raw\_hdr[RAW\_FRAME\_HDR\_SZ];
194   \textcolor{keywordtype}{size\_t} frame\_size = 0;
195 
196   \textcolor{keywordflow}{if} (fread(raw\_hdr, RAW\_FRAME\_HDR\_SZ, 1, infile) != 1) \{
197     \textcolor{keywordflow}{if} (!feof(infile)) warn(\textcolor{stringliteral}{"Failed to read RAW frame size\(\backslash\)n"});
198   \} \textcolor{keywordflow}{else} \{
199     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kCorruptFrameThreshold = 256 * 1024 * 1024;
200     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kFrameTooSmallThreshold = 256 * 1024;
201     frame\_size = mem\_get\_le32(raw\_hdr);
202 
203     \textcolor{keywordflow}{if} (frame\_size > kCorruptFrameThreshold) \{
204       warn(\textcolor{stringliteral}{"Read invalid frame size (%u)\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
205       frame\_size = 0;
206     \}
207 
208     \textcolor{keywordflow}{if} (frame\_size < kFrameTooSmallThreshold) \{
209       warn(\textcolor{stringliteral}{"Warning: Read invalid frame size (%u) - not a raw file?\(\backslash\)n"},
210            (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
211     \}
212 
213     \textcolor{keywordflow}{if} (frame\_size > *buffer\_size) \{
214       uint8\_t *new\_buf = realloc(*buffer, 2 * frame\_size);
215       \textcolor{keywordflow}{if} (new\_buf) \{
216         *buffer = new\_buf;
217         *buffer\_size = 2 * frame\_size;
218       \} \textcolor{keywordflow}{else} \{
219         warn(\textcolor{stringliteral}{"Failed to allocate compressed data buffer\(\backslash\)n"});
220         frame\_size = 0;
221       \}
222     \}
223   \}
224 
225   \textcolor{keywordflow}{if} (!feof(infile)) \{
226     \textcolor{keywordflow}{if} (fread(*buffer, 1, frame\_size, infile) != frame\_size) \{
227       warn(\textcolor{stringliteral}{"Failed to read full frame\(\backslash\)n"});
228       \textcolor{keywordflow}{return} 1;
229     \}
230     *bytes\_read = frame\_size;
231   \}
232 
233   \textcolor{keywordflow}{return} 0;
234 \}
235 
236 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxDecInputContext *input, uint8\_t **buf,
237                       \textcolor{keywordtype}{size\_t} *bytes\_in\_buffer, \textcolor{keywordtype}{size\_t} *buffer\_size) \{
238   \textcolor{keywordflow}{switch} (input->aom\_input\_ctx->file\_type) \{
239 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
240     \textcolor{keywordflow}{case} FILE\_TYPE\_WEBM:
241       \textcolor{keywordflow}{return} webm\_read\_frame(input->webm\_ctx, buf, bytes\_in\_buffer,
242                              buffer\_size);
243 \textcolor{preprocessor}{#endif}
244     \textcolor{keywordflow}{case} FILE\_TYPE\_RAW:
245       \textcolor{keywordflow}{return} raw\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
246                             buffer\_size);
247     \textcolor{keywordflow}{case} FILE\_TYPE\_IVF:
248       \textcolor{keywordflow}{return} ivf\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
249                             buffer\_size, NULL);
250     \textcolor{keywordflow}{case} FILE\_TYPE\_OBU:
251       \textcolor{keywordflow}{return} obudec\_read\_temporal\_unit(input->obu\_ctx, buf, bytes\_in\_buffer,
252                                        buffer\_size);
253     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 1;
254   \}
255 \}
256 
257 \textcolor{keyword}{static} \textcolor{keywordtype}{void} update\_image\_md5(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, \textcolor{keyword}{const} \textcolor{keywordtype}{int} planes[3],
258                              MD5Context *md5) \{
259   \textcolor{keywordtype}{int} i, y;
260 
261   \textcolor{keywordflow}{for} (i = 0; i < 3; ++i) \{
262     \textcolor{keyword}{const} \textcolor{keywordtype}{int} plane = planes[i];
263     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[plane];
264     \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[plane];
265     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = \hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(img, plane) *
266                   ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 2 : 1);
267     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(img, plane);
268 
269     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
270       MD5Update(md5, buf, w);
271       buf += stride;
272     \}
273   \}
274 \}
275 
276 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_image\_file(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, \textcolor{keyword}{const} \textcolor{keywordtype}{int} *planes,
277                              \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_planes, FILE *file) \{
278   \textcolor{keywordtype}{int} i, y;
279   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bytes\_per\_sample = ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 2 : 1);
280 
281   \textcolor{keywordflow}{for} (i = 0; i < num\_planes; ++i) \{
282     \textcolor{keyword}{const} \textcolor{keywordtype}{int} plane = planes[i];
283     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[plane];
284     \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[plane];
285     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = \hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(img, plane);
286     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(img, plane);
287 
288     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
289       fwrite(buf, bytes\_per\_sample, w, file);
290       buf += stride;
291     \}
292   \}
293 \}
294 
295 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_raw(\textcolor{keyword}{struct} AvxInputContext *input) \{
296   uint8\_t buf[32];
297   \textcolor{keywordtype}{int} is\_raw = 0;
298   \hyperlink{structaom__codec__stream__info}{aom\_codec\_stream\_info\_t} si;
299   memset(&si, 0, \textcolor{keyword}{sizeof}(si));
300 
301   \textcolor{keywordflow}{if} (fread(buf, 1, 32, input->file) == 32) \{
302     \textcolor{keywordtype}{int} i;
303 
304     \textcolor{keywordflow}{if} (mem\_get\_le32(buf) < 256 * 1024 * 1024) \{
305       \textcolor{keywordflow}{for} (i = 0; i < get\_aom\_decoder\_count(); ++i) \{
306         \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
307         \textcolor{keywordflow}{if} (!\hyperlink{group__decoder_ga2544bac9fdc439f0effd6b1b14df54be}{aom\_codec\_peek\_stream\_info}(decoder->codec\_interface(), buf + 4,
308                                         32 - 4, &si)) \{
309           is\_raw = 1;
310           input->fourcc = decoder->fourcc;
311           input->width = si.\hyperlink{structaom__codec__stream__info_add84a2752fefd706f893fbc41ba6b9f2}{w};
312           input->height = si.\hyperlink{structaom__codec__stream__info_a2f1c33e3b980b274176545340b474e34}{h};
313           input->framerate.numerator = 30;
314           input->framerate.denominator = 1;
315           \textcolor{keywordflow}{break};
316         \}
317       \}
318     \}
319   \}
320 
321   rewind(input->file);
322   \textcolor{keywordflow}{return} is\_raw;
323 \}
324 
325 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_progress(\textcolor{keywordtype}{int} frame\_in, \textcolor{keywordtype}{int} frame\_out, uint64\_t dx\_time) \{
326   fprintf(stderr,
327           \textcolor{stringliteral}{"%d decoded frames/%d showed frames in %"} PRId64 \textcolor{stringliteral}{" us (%.2f fps)\(\backslash\)r"},
328           frame\_in, frame\_out, dx\_time,
329           (\textcolor{keywordtype}{double})frame\_out * 1000000.0 / (\textcolor{keywordtype}{double})dx\_time);
330 \}
331 
332 \textcolor{keyword}{struct }ExternalFrameBuffer \{
333   uint8\_t *data;
334   \textcolor{keywordtype}{size\_t} size;
335   \textcolor{keywordtype}{int} in\_use;
336 \};
337 
338 \textcolor{keyword}{struct }ExternalFrameBufferList \{
339   \textcolor{keywordtype}{int} num\_external\_frame\_buffers;
340   \textcolor{keyword}{struct }ExternalFrameBuffer *ext\_fb;
341 \};
342 
343 \textcolor{comment}{// Callback used by libaom to request an external frame buffer. |cb\_priv|}
344 \textcolor{comment}{// Application private data passed into the set function. |min\_size| is the}
345 \textcolor{comment}{// minimum size in bytes needed to decode the next frame. |fb| pointer to the}
346 \textcolor{comment}{// frame buffer.}
347 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv, \textcolor{keywordtype}{size\_t} min\_size,
348                                 \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
349   \textcolor{keywordtype}{int} i;
350   \textcolor{keyword}{struct }ExternalFrameBufferList *\textcolor{keyword}{const} ext\_fb\_list =
351       (\textcolor{keyword}{struct }ExternalFrameBufferList *)cb\_priv;
352   \textcolor{keywordflow}{if} (ext\_fb\_list == NULL) \textcolor{keywordflow}{return} -1;
353 
354   \textcolor{comment}{// Find a free frame buffer.}
355   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list->num\_external\_frame\_buffers; ++i) \{
356     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].in\_use) \textcolor{keywordflow}{break};
357   \}
358 
359   \textcolor{keywordflow}{if} (i == ext\_fb\_list->num\_external\_frame\_buffers) \textcolor{keywordflow}{return} -1;
360 
361   \textcolor{keywordflow}{if} (ext\_fb\_list->ext\_fb[i].size < min\_size) \{
362     free(ext\_fb\_list->ext\_fb[i].data);
363     ext\_fb\_list->ext\_fb[i].data = (uint8\_t *)calloc(min\_size, \textcolor{keyword}{sizeof}(uint8\_t));
364     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].data) \textcolor{keywordflow}{return} -1;
365 
366     ext\_fb\_list->ext\_fb[i].size = min\_size;
367   \}
368 
369   fb->\hyperlink{structaom__codec__frame__buffer_a4b73719e1d6756516de8cbceb68822d2}{data} = ext\_fb\_list->ext\_fb[i].data;
370   fb->\hyperlink{structaom__codec__frame__buffer_a6fc24049c4e1706ce3a462825009f3d4}{size} = ext\_fb\_list->ext\_fb[i].size;
371   ext\_fb\_list->ext\_fb[i].in\_use = 1;
372 
373   \textcolor{comment}{// Set the frame buffer's private data to point at the external frame buffer.}
374   fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv} = &ext\_fb\_list->ext\_fb[i];
375   \textcolor{keywordflow}{return} 0;
376 \}
377 
378 \textcolor{comment}{// Callback used by libaom when there are no references to the frame buffer.}
379 \textcolor{comment}{// |cb\_priv| user private data passed into the set function. |fb| pointer}
380 \textcolor{comment}{// to the frame buffer.}
381 \textcolor{keyword}{static} \textcolor{keywordtype}{int} release\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv,
382                                     \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
383   \textcolor{keyword}{struct }ExternalFrameBuffer *\textcolor{keyword}{const} ext\_fb =
384       (\textcolor{keyword}{struct }ExternalFrameBuffer *)fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv};
385   (\textcolor{keywordtype}{void})cb\_priv;
386   ext\_fb->in\_use = 0;
387   \textcolor{keywordflow}{return} 0;
388 \}
389 
390 \textcolor{keyword}{static} \textcolor{keywordtype}{void} generate\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *pattern, \textcolor{keywordtype}{char} *out, \textcolor{keywordtype}{size\_t} q\_len,
391                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_h,
392                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in) \{
393   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = pattern;
394   \textcolor{keywordtype}{char} *q = out;
395 
396   \textcolor{keywordflow}{do} \{
397     \textcolor{keywordtype}{char} *next\_pat = strchr(p, \textcolor{charliteral}{'%'});
398 
399     \textcolor{keywordflow}{if} (p == next\_pat) \{
400       \textcolor{keywordtype}{size\_t} pat\_len;
401 
402       \textcolor{comment}{/* parse the pattern */}
403       q[q\_len - 1] = \textcolor{charliteral}{'\(\backslash\)0'};
404       \textcolor{keywordflow}{switch} (p[1]) \{
405         \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_w); \textcolor{keywordflow}{break};
406         \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_h); \textcolor{keywordflow}{break};
407         \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, frame\_in); \textcolor{keywordflow}{break};
408         \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%02d"}, frame\_in); \textcolor{keywordflow}{break};
409         \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%03d"}, frame\_in); \textcolor{keywordflow}{break};
410         \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%04d"}, frame\_in); \textcolor{keywordflow}{break};
411         \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%05d"}, frame\_in); \textcolor{keywordflow}{break};
412         \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%06d"}, frame\_in); \textcolor{keywordflow}{break};
413         \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%07d"}, frame\_in); \textcolor{keywordflow}{break};
414         \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%08d"}, frame\_in); \textcolor{keywordflow}{break};
415         \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%09d"}, frame\_in); \textcolor{keywordflow}{break};
416         \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Unrecognized pattern %%%c\(\backslash\)n"}, p[1]); \textcolor{keywordflow}{break};
417       \}
418 
419       pat\_len = strlen(q);
420       \textcolor{keywordflow}{if} (pat\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
421       q += pat\_len;
422       p += 2;
423       q\_len -= pat\_len;
424     \} \textcolor{keywordflow}{else} \{
425       \textcolor{keywordtype}{size\_t} copy\_len;
426 
427       \textcolor{comment}{/* copy the next segment */}
428       \textcolor{keywordflow}{if} (!next\_pat)
429         copy\_len = strlen(p);
430       \textcolor{keywordflow}{else}
431         copy\_len = next\_pat - p;
432 
433       \textcolor{keywordflow}{if} (copy\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
434 
435       memcpy(q, p, copy\_len);
436       q[copy\_len] = \textcolor{charliteral}{'\(\backslash\)0'};
437       q += copy\_len;
438       p += copy\_len;
439       q\_len -= copy\_len;
440     \}
441   \} \textcolor{keywordflow}{while} (*p);
442 \}
443 
444 \textcolor{keyword}{static} \textcolor{keywordtype}{int} is\_single\_file(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern) \{
445   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = outfile\_pattern;
446 
447   \textcolor{keywordflow}{do} \{
448     p = strchr(p, \textcolor{charliteral}{'%'});
449     \textcolor{keywordflow}{if} (p && p[1] >= \textcolor{charliteral}{'1'} && p[1] <= \textcolor{charliteral}{'9'})
450       \textcolor{keywordflow}{return} 0;  \textcolor{comment}{// pattern contains sequence number, so it's not unique}
451     \textcolor{keywordflow}{if} (p) p++;
452   \} \textcolor{keywordflow}{while} (p);
453 
454   \textcolor{keywordflow}{return} 1;
455 \}
456 
457 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16], \textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename) \{
458   \textcolor{keywordtype}{int} i;
459 
460   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) printf(\textcolor{stringliteral}{"%02x"}, digest[i]);
461   printf(\textcolor{stringliteral}{"  %s\(\backslash\)n"}, filename);
462 \}
463 
464 \textcolor{keyword}{static} FILE *open\_outfile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name) \{
465   \textcolor{keywordflow}{if} (strcmp(\textcolor{stringliteral}{"-"}, name) == 0) \{
466     set\_binary\_mode(stdout);
467     \textcolor{keywordflow}{return} stdout;
468   \} \textcolor{keywordflow}{else} \{
469     FILE *file = fopen(name, \textcolor{stringliteral}{"wb"});
470     \textcolor{keywordflow}{if} (!file) fatal(\textcolor{stringliteral}{"Failed to open output file '%s'"}, name);
471     \textcolor{keywordflow}{return} file;
472   \}
473 \}
474 
475 \textcolor{keyword}{static} \textcolor{keywordtype}{int} img\_shifted\_realloc\_required(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
476                                         \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *shifted,
477                                         \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} required\_fmt) \{
478   \textcolor{keywordflow}{return} img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != shifted->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != shifted->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} ||
479          required\_fmt != shifted->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt};
480 \}
481 
482 \textcolor{keyword}{static} \textcolor{keywordtype}{int} main\_loop(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
483   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
484   \textcolor{keywordtype}{char} *fn = NULL;
485   \textcolor{keywordtype}{int} i;
486   \textcolor{keywordtype}{int} ret = EXIT\_FAILURE;
487   uint8\_t *buf = NULL;
488   \textcolor{keywordtype}{size\_t} bytes\_in\_buffer = 0, buffer\_size = 0;
489   FILE *infile;
490   \textcolor{keywordtype}{int} frame\_in = 0, frame\_out = 0, flipuv = 0, noblit = 0;
491   \textcolor{keywordtype}{int} do\_md5 = 0, progress = 0;
492   \textcolor{keywordtype}{int} stop\_after = 0, postproc = 0, summary = 0, quiet = 1;
493   \textcolor{keywordtype}{int} arg\_skip = 0;
494   \textcolor{keywordtype}{int} keep\_going = 0;
495   \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{interface }= NULL;
496   \textcolor{keyword}{const} AvxInterface *fourcc\_interface = NULL;
497   uint64\_t dx\_time = 0;
498   \textcolor{keyword}{struct }arg arg;
499   \textcolor{keywordtype}{char} **argv, **argi, **argj;
500 
501   \textcolor{keywordtype}{int} single\_file;
502   \textcolor{keywordtype}{int} use\_y4m = 1;
503   \textcolor{keywordtype}{int} opt\_yv12 = 0;
504   \textcolor{keywordtype}{int} opt\_i420 = 0;
505   \textcolor{keywordtype}{int} opt\_raw = 0;
506   \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
507   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} output\_bit\_depth = 0;
508   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_mode = 0;
509   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} is\_annexb = 0;
510   \textcolor{keywordtype}{int} tile\_row = -1;
511   \textcolor{keywordtype}{int} tile\_col = -1;
512   \textcolor{keywordtype}{int} frames\_corrupted = 0;
513   \textcolor{keywordtype}{int} dec\_flags = 0;
514   \textcolor{keywordtype}{int} do\_scale = 0;
515   \textcolor{keywordtype}{int} operating\_point = 0;
516   \textcolor{keywordtype}{int} output\_all\_layers = 0;
517   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} row\_mt = 0;
518   \hyperlink{structaom__image}{aom\_image\_t} *scaled\_img = NULL;
519   \hyperlink{structaom__image}{aom\_image\_t} *img\_shifted = NULL;
520   \textcolor{keywordtype}{int} frame\_avail, got\_data, flush\_decoder = 0;
521   \textcolor{keywordtype}{int} num\_external\_frame\_buffers = 0;
522   \textcolor{keyword}{struct }ExternalFrameBufferList ext\_fb\_list = \{ 0, NULL \};
523 
524   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern = NULL;
525   \textcolor{keywordtype}{char} outfile\_name[PATH\_MAX] = \{ 0 \};
526   FILE *outfile = NULL;
527 
528   FILE *framestats\_file = NULL;
529 
530   MD5Context md5\_ctx;
531   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} md5\_digest[16];
532 
533   \textcolor{keyword}{struct }AvxDecInputContext input = \{ NULL, NULL, NULL \};
534   \textcolor{keyword}{struct }AvxInputContext aom\_input\_ctx;
535   memset(&aom\_input\_ctx, 0, \textcolor{keyword}{sizeof}(aom\_input\_ctx));
536 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
537   \textcolor{keyword}{struct }WebmInputContext webm\_ctx;
538   memset(&webm\_ctx, 0, \textcolor{keyword}{sizeof}(webm\_ctx));
539   input.webm\_ctx = &webm\_ctx;
540 \textcolor{preprocessor}{#endif}
541   \textcolor{keyword}{struct }ObuDecInputContext obu\_ctx = \{ NULL, NULL, 0, 0, 0 \};
542 
543   obu\_ctx.avx\_ctx = &aom\_input\_ctx;
544   input.obu\_ctx = &obu\_ctx;
545   input.aom\_input\_ctx = &aom\_input\_ctx;
546 
547   \textcolor{comment}{/* Parse command line */}
548   exec\_name = argv\_[0];
549   argv = argv\_dup(argc - 1, argv\_ + 1);
550 
551   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
552     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
553     arg.argv\_step = 1;
554 
555     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
556       show\_help(stdout, 0);
557       exit(EXIT\_SUCCESS);
558     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
559       \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_name(arg.val);
560       \textcolor{keywordflow}{if} (!interface)
561         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
562     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
563       \textcolor{comment}{// no-op}
564     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
565       outfile\_pattern = arg.val;
566     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi)) \{
567       use\_y4m = 0;
568       flipuv = 1;
569       opt\_yv12 = 1;
570       opt\_i420 = 0;
571       opt\_raw = 0;
572     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi)) \{
573       use\_y4m = 0;
574       flipuv = 0;
575       opt\_yv12 = 0;
576       opt\_i420 = 1;
577       opt\_raw = 0;
578     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rawvideo, argi)) \{
579       use\_y4m = 0;
580       opt\_yv12 = 0;
581       opt\_i420 = 0;
582       opt\_raw = 1;
583     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &flipuvarg, argi)) \{
584       flipuv = 1;
585     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &noblitarg, argi)) \{
586       noblit = 1;
587     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &progressarg, argi)) \{
588       progress = 1;
589     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limitarg, argi)) \{
590       stop\_after = arg\_parse\_uint(&arg);
591     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skiparg, argi)) \{
592       arg\_skip = arg\_parse\_uint(&arg);
593     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &postprocarg, argi)) \{
594       postproc = 1;
595     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &md5arg, argi)) \{
596       do\_md5 = 1;
597     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framestatsarg, argi)) \{
598       framestats\_file = fopen(arg.val, \textcolor{stringliteral}{"w"});
599       \textcolor{keywordflow}{if} (!framestats\_file) \{
600         die(\textcolor{stringliteral}{"Error: Could not open --framestats file (%s) for writing.\(\backslash\)n"},
601             arg.val);
602       \}
603     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &summaryarg, argi)) \{
604       summary = 1;
605     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threadsarg, argi)) \{
606       cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads} = arg\_parse\_uint(&arg);
607     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rowmtarg, argi)) \{
608       row\_mt = arg\_parse\_uint(&arg);
609     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi)) \{
610       quiet = 0;
611     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &scalearg, argi)) \{
612       do\_scale = 1;
613     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fb\_arg, argi)) \{
614       num\_external\_frame\_buffers = arg\_parse\_uint(&arg);
615     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &continuearg, argi)) \{
616       keep\_going = 1;
617     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outbitdeptharg, argi)) \{
618       output\_bit\_depth = arg\_parse\_uint(&arg);
619     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tilem, argi)) \{
620       tile\_mode = arg\_parse\_int(&arg);
621     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &isannexb, argi)) \{
622       is\_annexb = 1;
623       input.obu\_ctx->is\_annexb = 1;
624     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tiler, argi)) \{
625       tile\_row = arg\_parse\_int(&arg);
626     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tilec, argi)) \{
627       tile\_col = arg\_parse\_int(&arg);
628     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &oppointarg, argi)) \{
629       operating\_point = arg\_parse\_int(&arg);
630     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outallarg, argi)) \{
631       output\_all\_layers = 1;
632     \} \textcolor{keywordflow}{else} \{
633       argj++;
634     \}
635   \}
636 
637   \textcolor{comment}{/* Check for unrecognized options */}
638   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
639     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && strlen(argi[0]) > 1)
640       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
641 
642   \textcolor{comment}{/* Handle non-option arguments */}
643   fn = argv[0];
644 
645   \textcolor{keywordflow}{if} (!fn) \{
646     free(argv);
647     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
648     usage\_exit();
649   \}
650   \textcolor{comment}{/* Open file */}
651   infile = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"rb"}) : set\_binary\_mode(stdin);
652 
653   \textcolor{keywordflow}{if} (!infile) \{
654     fatal(\textcolor{stringliteral}{"Failed to open input file '%s'"}, strcmp(fn, \textcolor{stringliteral}{"-"}) ? fn : \textcolor{stringliteral}{"stdin"});
655   \}
656 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
657   \textcolor{comment}{/* Make sure we don't dump to the terminal, unless forced to with -o - */}
658   \textcolor{keywordflow}{if} (!outfile\_pattern && isatty(STDOUT\_FILENO) && !do\_md5 && !noblit) \{
659     fprintf(stderr,
660             \textcolor{stringliteral}{"Not dumping raw video to your terminal. Use '-o -' to "}
661             \textcolor{stringliteral}{"override.\(\backslash\)n"});
662     \textcolor{keywordflow}{return} EXIT\_FAILURE;
663   \}
664 \textcolor{preprocessor}{#endif}
665   input.aom\_input\_ctx->filename = fn;
666   input.aom\_input\_ctx->file = infile;
667   \textcolor{keywordflow}{if} (file\_is\_ivf(input.aom\_input\_ctx))
668     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_IVF;
669 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
670   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_webm(input.webm\_ctx, input.aom\_input\_ctx))
671     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_WEBM;
672 \textcolor{preprocessor}{#endif}
673   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_obu(&obu\_ctx))
674     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_OBU;
675   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_raw(input.aom\_input\_ctx))
676     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_RAW;
677   \textcolor{keywordflow}{else} \{
678     fprintf(stderr, \textcolor{stringliteral}{"Unrecognized input file type.\(\backslash\)n"});
679 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
680     fprintf(stderr, \textcolor{stringliteral}{"aomdec was built without WebM container support.\(\backslash\)n"});
681 \textcolor{preprocessor}{#endif}
682     \textcolor{keywordflow}{return} EXIT\_FAILURE;
683   \}
684 
685   outfile\_pattern = outfile\_pattern ? outfile\_pattern : \textcolor{stringliteral}{"-"};
686   single\_file = is\_single\_file(outfile\_pattern);
687 
688   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
689     generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX,
690                       aom\_input\_ctx.width, aom\_input\_ctx.height, 0);
691     \textcolor{keywordflow}{if} (do\_md5)
692       MD5Init(&md5\_ctx);
693     \textcolor{keywordflow}{else}
694       outfile = open\_outfile(outfile\_name);
695   \}
696 
697   \textcolor{keywordflow}{if} (use\_y4m && !noblit) \{
698     \textcolor{keywordflow}{if} (!single\_file) \{
699       fprintf(stderr,
700               \textcolor{stringliteral}{"YUV4MPEG2 not supported with output patterns,"}
701               \textcolor{stringliteral}{" try --i420 or --yv12 or --rawvideo.\(\backslash\)n"});
702       \textcolor{keywordflow}{return} EXIT\_FAILURE;
703     \}
704 
705 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
706     \textcolor{keywordflow}{if} (aom\_input\_ctx.file\_type == FILE\_TYPE\_WEBM) \{
707       \textcolor{keywordflow}{if} (webm\_guess\_framerate(input.webm\_ctx, input.aom\_input\_ctx)) \{
708         fprintf(stderr,
709                 \textcolor{stringliteral}{"Failed to guess framerate -- error parsing "}
710                 \textcolor{stringliteral}{"webm file?\(\backslash\)n"});
711         \textcolor{keywordflow}{return} EXIT\_FAILURE;
712       \}
713     \}
714 \textcolor{preprocessor}{#endif}
715   \}
716 
717   fourcc\_interface = get\_aom\_decoder\_by\_fourcc(aom\_input\_ctx.fourcc);
718   \textcolor{keywordflow}{if} (interface && fourcc\_interface && interface != fourcc\_interface)
719     warn(\textcolor{stringliteral}{"Header indicates codec: %s\(\backslash\)n"}, fourcc\_interface->name);
720   \textcolor{keywordflow}{else}
721     \textcolor{keyword}{interface }= fourcc\_interface;
722 
723   \textcolor{keywordflow}{if} (!interface) \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_index(0);
724 
725   dec\_flags = (postproc ? \hyperlink{group__decoder_ga7b6c145833964c9edd3ff78be017f7ec}{AOM\_CODEC\_USE\_POSTPROC} : 0);
726   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&decoder, interface->codec\_interface(), &cfg,
727                          dec\_flags)) \{
728     fprintf(stderr, \textcolor{stringliteral}{"Failed to initialize decoder: %s\(\backslash\)n"},
729             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
730     \textcolor{keywordflow}{goto} fail2;
731   \}
732 
733   \textcolor{keywordflow}{if} (!quiet) fprintf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, decoder.\hyperlink{structaom__codec__ctx_a3aa8abff3e05d2fbbf4f5a9fa0575f2b}{name});
734 
735 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
736   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, tile\_mode)) \{
737     fprintf(stderr, \textcolor{stringliteral}{"Failed to set decode\_tile\_mode: %s\(\backslash\)n"},
738             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
739     \textcolor{keywordflow}{goto} fail;
740   \}
741 
742   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, is\_annexb)) \{
743     fprintf(stderr, \textcolor{stringliteral}{"Failed to set is\_annexb: %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
744     \textcolor{keywordflow}{goto} fail;
745   \}
746 
747   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tile\_row
      )) \{
748     fprintf(stderr, \textcolor{stringliteral}{"Failed to set decode\_tile\_row: %s\(\backslash\)n"},
749             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
750     \textcolor{keywordflow}{goto} fail;
751   \}
752 
753   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, AV1\_SET\_DECODE\_TILE\_COL, tile\_col)) \{
754     fprintf(stderr, \textcolor{stringliteral}{"Failed to set decode\_tile\_col: %s\(\backslash\)n"},
755             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
756     \textcolor{keywordflow}{goto} fail;
757   \}
758 
759   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa8b955fc5a2f6e33c6dad858d7c15f67}{AV1D\_SET\_OPERATING\_POINT}, 
      operating\_point)) \{
760     fprintf(stderr, \textcolor{stringliteral}{"Failed to set operating\_point: %s\(\backslash\)n"},
761             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
762     \textcolor{keywordflow}{goto} fail;
763   \}
764 
765   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba8d51f96b8877b665225f5cfaa73ded8e}{AV1D\_SET\_OUTPUT\_ALL\_LAYERS},
766                         output\_all\_layers)) \{
767     fprintf(stderr, \textcolor{stringliteral}{"Failed to set output\_all\_layers: %s\(\backslash\)n"},
768             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
769     \textcolor{keywordflow}{goto} fail;
770   \}
771 
772   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4784af3a10d73a36f739cb1c99caf876}{AV1D\_SET\_ROW\_MT}, row\_mt)) \{
773     fprintf(stderr, \textcolor{stringliteral}{"Failed to set row\_mt: %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
774     \textcolor{keywordflow}{goto} fail;
775   \}
776 \textcolor{preprocessor}{#endif}
777 
778   \textcolor{keywordflow}{if} (arg\_skip) fprintf(stderr, \textcolor{stringliteral}{"Skipping first %d frames.\(\backslash\)n"}, arg\_skip);
779   \textcolor{keywordflow}{while} (arg\_skip) \{
780     \textcolor{keywordflow}{if} (read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \textcolor{keywordflow}{break};
781     arg\_skip--;
782   \}
783 
784   \textcolor{keywordflow}{if} (num\_external\_frame\_buffers > 0) \{
785     ext\_fb\_list.num\_external\_frame\_buffers = num\_external\_frame\_buffers;
786     ext\_fb\_list.ext\_fb = (\textcolor{keyword}{struct }ExternalFrameBuffer *)calloc(
787         num\_external\_frame\_buffers, \textcolor{keyword}{sizeof}(*ext\_fb\_list.ext\_fb));
788     \textcolor{keywordflow}{if} (\hyperlink{group__cap__external__frame__buffer_ga1818a812e4d1e70eeafbe5b0ee538d6e}{aom\_codec\_set\_frame\_buffer\_functions}(&decoder, 
      get\_av1\_frame\_buffer,
789                                              release\_av1\_frame\_buffer,
790                                              &ext\_fb\_list)) \{
791       fprintf(stderr, \textcolor{stringliteral}{"Failed to configure external frame buffers: %s\(\backslash\)n"},
792               \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
793       \textcolor{keywordflow}{goto} fail;
794     \}
795   \}
796 
797   frame\_avail = 1;
798   got\_data = 0;
799 
800   \textcolor{keywordflow}{if} (framestats\_file) fprintf(framestats\_file, \textcolor{stringliteral}{"bytes,qp\(\backslash\)r\(\backslash\)n"});
801 
802   \textcolor{comment}{/* Decode file */}
803   \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
804     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
805     \hyperlink{structaom__image}{aom\_image\_t} *img;
806     \textcolor{keyword}{struct }aom\_usec\_timer timer;
807     \textcolor{keywordtype}{int} corrupted = 0;
808 
809     frame\_avail = 0;
810     \textcolor{keywordflow}{if} (!stop\_after || frame\_in < stop\_after) \{
811       \textcolor{keywordflow}{if} (!read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \{
812         frame\_avail = 1;
813         frame\_in++;
814 
815         aom\_usec\_timer\_start(&timer);
816 
817         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, buf, bytes\_in\_buffer, NULL)) \{
818           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(&decoder);
819           warn(\textcolor{stringliteral}{"Failed to decode frame %d: %s"}, frame\_in,
820                \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
821 
822           \textcolor{keywordflow}{if} (detail) warn(\textcolor{stringliteral}{"Additional information: %s"}, detail);
823           \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
824         \}
825 
826         \textcolor{keywordflow}{if} (framestats\_file) \{
827           \textcolor{keywordtype}{int} qp;
828           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa984acc8b42df9c7d18fc3556a14fd29}{AOMD\_GET\_LAST\_QUANTIZER}, &qp)) \{
829             warn(\textcolor{stringliteral}{"Failed AOMD\_GET\_LAST\_QUANTIZER: %s"},
830                  \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
831             \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
832           \}
833           fprintf(framestats\_file, \textcolor{stringliteral}{"%d,%d\(\backslash\)r\(\backslash\)n"}, (\textcolor{keywordtype}{int})bytes\_in\_buffer, qp);
834         \}
835 
836         aom\_usec\_timer\_mark(&timer);
837         dx\_time += aom\_usec\_timer\_elapsed(&timer);
838       \} \textcolor{keywordflow}{else} \{
839         flush\_decoder = 1;
840       \}
841     \} \textcolor{keywordflow}{else} \{
842       flush\_decoder = 1;
843     \}
844 
845     aom\_usec\_timer\_start(&timer);
846 
847     \textcolor{keywordflow}{if} (flush\_decoder) \{
848       \textcolor{comment}{// Flush the decoder in frame parallel decode.}
849       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, NULL, 0, NULL)) \{
850         warn(\textcolor{stringliteral}{"Failed to flush decoder: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
851       \}
852     \}
853 
854     aom\_usec\_timer\_mark(&timer);
855     dx\_time += aom\_usec\_timer\_elapsed(&timer);
856 
857     got\_data = 0;
858     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&decoder, &iter))) \{
859       ++frame\_out;
860       got\_data = 1;
861 
862       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba159ddb748cb69956226b7c13e3890ff6}{AOMD\_GET\_FRAME\_CORRUPTED}, &
      corrupted)) \{
863         warn(\textcolor{stringliteral}{"Failed AOM\_GET\_FRAME\_CORRUPTED: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
864         \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
865       \}
866       frames\_corrupted += corrupted;
867 
868       \textcolor{keywordflow}{if} (progress) show\_progress(frame\_in, frame\_out, dx\_time);
869 
870       \textcolor{keywordflow}{if} (!noblit) \{
871         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YUV[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a0845e9194541329c0f77b4bd6a38cc7c}{AOM\_PLANE\_U}, AOM\_PLANE\_V \};
872         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YVU[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a32a43f20adb01d846af1925189c37495}{AOM\_PLANE\_V}, AOM\_PLANE\_U \};
873         \textcolor{keyword}{const} \textcolor{keywordtype}{int} *planes = flipuv ? PLANES\_YVU : PLANES\_YUV;
874 
875         \textcolor{keywordflow}{if} (do\_scale) \{
876           \textcolor{keywordflow}{if} (frame\_out == 1) \{
877             \textcolor{comment}{// If the output frames are to be scaled to a fixed display size}
878             \textcolor{comment}{// then use the width and height specified in the container. If}
879             \textcolor{comment}{// either of these is set to 0, use the display size set in the}
880             \textcolor{comment}{// first frame header. If that is unavailable, use the raw decoded}
881             \textcolor{comment}{// size of the first decoded frame.}
882             \textcolor{keywordtype}{int} render\_width = aom\_input\_ctx.width;
883             \textcolor{keywordtype}{int} render\_height = aom\_input\_ctx.height;
884             \textcolor{keywordflow}{if} (!render\_width || !render\_height) \{
885               \textcolor{keywordtype}{int} render\_size[2];
886               \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba592a5d1390204d743ddfe7bfe8ef177c}{AV1D\_GET\_DISPLAY\_SIZE},
887                                     render\_size)) \{
888                 \textcolor{comment}{// As last resort use size of first frame as display size.}
889                 render\_width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
890                 render\_height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
891               \} \textcolor{keywordflow}{else} \{
892                 render\_width = render\_size[0];
893                 render\_height = render\_size[1];
894               \}
895             \}
896             scaled\_img =
897                 \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, render\_width, render\_height, 16);
898             scaled\_img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
899           \}
900 
901           \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != scaled\_img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != scaled\_img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}) \{
902 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
903             libyuv\_scale(img, scaled\_img, kFilterBox);
904             img = scaled\_img;
905 \textcolor{preprocessor}{#else}
906             fprintf(
907                 stderr,
908                 \textcolor{stringliteral}{"Failed to scale output frame: %s.\(\backslash\)n"}
909                 \textcolor{stringliteral}{"libyuv is required for scaling but is currently disabled.\(\backslash\)n"}
910                 \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running cmake.\(\backslash\)n"},
911                 \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
912             \textcolor{keywordflow}{goto} fail;
913 \textcolor{preprocessor}{#endif}
914           \}
915         \}
916         \textcolor{comment}{// Default to codec bit depth if output bit depth not set}
917         \textcolor{keywordflow}{if} (!output\_bit\_depth && single\_file && !do\_md5) \{
918           output\_bit\_depth = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
919         \}
920         \textcolor{comment}{// Shift up or down if necessary}
921         \textcolor{keywordflow}{if} (output\_bit\_depth != 0) \{
922           \textcolor{keyword}{const} \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} shifted\_fmt =
923               output\_bit\_depth == 8
924                   ? img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} ^ (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})
925                   : img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} | \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
926 
927           if (shifted\_fmt != img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} || output\_bit\_depth != img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth}) \{
928             \textcolor{keywordflow}{if} (img\_shifted &&
929                 img\_shifted\_realloc\_required(img, img\_shifted, shifted\_fmt)) \{
930               \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(img\_shifted);
931               img\_shifted = NULL;
932             \}
933             \textcolor{keywordflow}{if} (!img\_shifted) \{
934               img\_shifted =
935                   \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, shifted\_fmt, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
936               img\_shifted->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = output\_bit\_depth;
937               img\_shifted->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome} = img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome};
938             \}
939             \textcolor{keywordflow}{if} (output\_bit\_depth > img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth}) \{
940               aom\_img\_upshift(img\_shifted, img,
941                               output\_bit\_depth - img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth});
942             \} \textcolor{keywordflow}{else} \{
943               aom\_img\_downshift(img\_shifted, img,
944                                 img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} - output\_bit\_depth);
945             \}
946             img = img\_shifted;
947           \}
948         \}
949 
950         aom\_input\_ctx.width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
951         aom\_input\_ctx.height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
952 
953         \textcolor{keywordtype}{int} num\_planes = (!use\_y4m && opt\_raw && img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome}) ? 1 : 3;
954 
955         \textcolor{keywordflow}{if} (single\_file) \{
956           \textcolor{keywordflow}{if} (use\_y4m) \{
957             \textcolor{keywordtype}{char} y4m\_buf[Y4M\_BUFFER\_SIZE] = \{ 0 \};
958             \textcolor{keywordtype}{size\_t} len = 0;
959             \textcolor{keywordflow}{if} (frame\_out == 1) \{
960               \textcolor{comment}{// Y4M file header}
961               len = y4m\_write\_file\_header(
962                   y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf), aom\_input\_ctx.width,
963                   aom\_input\_ctx.height, &aom\_input\_ctx.framerate, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt},
964                   img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth});
965               \textcolor{keywordflow}{if} (do\_md5) \{
966                 MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
967               \} \textcolor{keywordflow}{else} \{
968                 fputs(y4m\_buf, outfile);
969               \}
970             \}
971 
972             \textcolor{comment}{// Y4M frame header}
973             len = y4m\_write\_frame\_header(y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf));
974             \textcolor{keywordflow}{if} (do\_md5) \{
975               MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
976             \} \textcolor{keywordflow}{else} \{
977               fputs(y4m\_buf, outfile);
978             \}
979           \} \textcolor{keywordflow}{else} \{
980             \textcolor{keywordflow}{if} (frame\_out == 1) \{
981               \textcolor{comment}{// Check if --yv12 or --i420 options are consistent with the}
982               \textcolor{comment}{// bit-stream decoded}
983               \textcolor{keywordflow}{if} (opt\_i420) \{
984                 \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
985                     img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
986                   fprintf(stderr,
987                           \textcolor{stringliteral}{"Cannot produce i420 output for bit-stream.\(\backslash\)n"});
988                   \textcolor{keywordflow}{goto} fail;
989                 \}
990               \}
991               \textcolor{keywordflow}{if} (opt\_yv12) \{
992                 \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
993                      img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) ||
994                     img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} != 8) \{
995                   fprintf(stderr,
996                           \textcolor{stringliteral}{"Cannot produce yv12 output for bit-stream.\(\backslash\)n"});
997                   \textcolor{keywordflow}{goto} fail;
998                 \}
999               \}
1000             \}
1001           \}
1002 
1003           \textcolor{keywordflow}{if} (do\_md5) \{
1004             update\_image\_md5(img, planes, &md5\_ctx);
1005           \} \textcolor{keywordflow}{else} \{
1006             write\_image\_file(img, planes, num\_planes, outfile);
1007           \}
1008         \} \textcolor{keywordflow}{else} \{
1009           generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
1010                             img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, frame\_in);
1011           \textcolor{keywordflow}{if} (do\_md5) \{
1012             MD5Init(&md5\_ctx);
1013             update\_image\_md5(img, planes, &md5\_ctx);
1014             MD5Final(md5\_digest, &md5\_ctx);
1015             print\_md5(md5\_digest, outfile\_name);
1016           \} \textcolor{keywordflow}{else} \{
1017             outfile = open\_outfile(outfile\_name);
1018             write\_image\_file(img, planes, num\_planes, outfile);
1019             fclose(outfile);
1020           \}
1021         \}
1022       \}
1023     \}
1024   \}
1025 
1026   \textcolor{keywordflow}{if} (summary || progress) \{
1027     show\_progress(frame\_in, frame\_out, dx\_time);
1028     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
1029   \}
1030 
1031   \textcolor{keywordflow}{if} (frames\_corrupted) \{
1032     fprintf(stderr, \textcolor{stringliteral}{"WARNING: %d frames corrupted.\(\backslash\)n"}, frames\_corrupted);
1033   \} \textcolor{keywordflow}{else} \{
1034     ret = EXIT\_SUCCESS;
1035   \}
1036 
1037 fail:
1038 
1039   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&decoder)) \{
1040     fprintf(stderr, \textcolor{stringliteral}{"Failed to destroy decoder: %s\(\backslash\)n"},
1041             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
1042   \}
1043 
1044 fail2:
1045 
1046   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
1047     \textcolor{keywordflow}{if} (do\_md5) \{
1048       MD5Final(md5\_digest, &md5\_ctx);
1049       print\_md5(md5\_digest, outfile\_name);
1050     \} \textcolor{keywordflow}{else} \{
1051       fclose(outfile);
1052     \}
1053   \}
1054 
1055 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1056   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_WEBM)
1057     webm\_free(input.webm\_ctx);
1058 \textcolor{preprocessor}{#endif}
1059   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_OBU)
1060     obudec\_free(input.obu\_ctx);
1061 
1062   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type != FILE\_TYPE\_WEBM) free(buf);
1063 
1064   \textcolor{keywordflow}{if} (scaled\_img) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(scaled\_img);
1065   \textcolor{keywordflow}{if} (img\_shifted) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(img\_shifted);
1066 
1067   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list.num\_external\_frame\_buffers; ++i) \{
1068     free(ext\_fb\_list.ext\_fb[i].data);
1069   \}
1070   free(ext\_fb\_list.ext\_fb);
1071 
1072   fclose(infile);
1073   \textcolor{keywordflow}{if} (framestats\_file) fclose(framestats\_file);
1074 
1075   free(argv);
1076 
1077   \textcolor{keywordflow}{return} ret;
1078 \}
1079 
1080 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
1081   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} loops = 1, i;
1082   \textcolor{keywordtype}{char} **argv, **argi, **argj;
1083   \textcolor{keyword}{struct }arg arg;
1084   \textcolor{keywordtype}{int} error = 0;
1085 
1086   argv = argv\_dup(argc - 1, argv\_ + 1);
1087   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1088     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
1089     arg.argv\_step = 1;
1090 
1091     \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
1092       loops = arg\_parse\_uint(&arg);
1093       \textcolor{keywordflow}{break};
1094     \}
1095   \}
1096   free(argv);
1097   \textcolor{keywordflow}{for} (i = 0; !error && i < loops; i++) error = main\_loop(argc, argv\_);
1098   \textcolor{keywordflow}{return} error;
1099 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomenc}{}\subsection{aomenc}\label{example_aomenc}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include "apps/aomenc.h"}
13 
14 \textcolor{preprocessor}{#include "config/aom\_config.h"}
15 
16 \textcolor{preprocessor}{#include <assert.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 \textcolor{preprocessor}{#include <math.h>}
19 \textcolor{preprocessor}{#include <stdarg.h>}
20 \textcolor{preprocessor}{#include <stdio.h>}
21 \textcolor{preprocessor}{#include <stdlib.h>}
22 \textcolor{preprocessor}{#include <string.h>}
23 
24 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
25 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
26 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
30 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
31 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
32 \textcolor{preprocessor}{#include "aom\_dsp/aom\_dsp\_common.h"}
33 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
34 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
35 \textcolor{preprocessor}{#include "common/args.h"}
36 \textcolor{preprocessor}{#include "common/ivfenc.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 \textcolor{preprocessor}{#include "common/warnings.h"}
39 
40 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
41 \textcolor{preprocessor}{#include "common/webmenc.h"}
42 \textcolor{preprocessor}{#endif}
43 
44 \textcolor{preprocessor}{#include "common/y4minput.h"}
45 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
46 \textcolor{preprocessor}{#include "stats/aomstats.h"}
47 \textcolor{preprocessor}{#include "stats/rate\_hist.h"}
48 
49 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
50 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
51 \textcolor{preprocessor}{#endif}
52 
53 
54 \textcolor{comment}{/* Swallow warnings about unused results of fread/fwrite */}
55 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fread(\textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb, FILE *stream) \{
56   \textcolor{keywordflow}{return} fread(ptr, size, nmemb, stream);
57 \}
58 \textcolor{preprocessor}{#define fread wrap\_fread}
59 
60 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fwrite(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb,
61                           FILE *stream) \{
62   \textcolor{keywordflow}{return} fwrite(ptr, size, nmemb, stream);
63 \}
64 \textcolor{preprocessor}{#define fwrite wrap\_fwrite}
65 
66 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
67 
68 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_errorv(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
69                                    \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, va\_list ap) \{
70   \textcolor{keywordflow}{if} (ctx->\hyperlink{structaom__codec__ctx_a4cf9c265a7c34e92bb02d04aa3cab718}{err}) \{
71     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(ctx);
72 
73     vfprintf(stderr, s, ap);
74     fprintf(stderr, \textcolor{stringliteral}{": %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(ctx));
75 
76     \textcolor{keywordflow}{if} (detail) fprintf(stderr, \textcolor{stringliteral}{"    %s\(\backslash\)n"}, detail);
77 
78     \textcolor{keywordflow}{if} (fatal) exit(EXIT\_FAILURE);
79   \}
80 \}
81 
82 \textcolor{keyword}{static} \textcolor{keywordtype}{void} ctx\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
83   va\_list ap;
84 
85   va\_start(ap, s);
86   warn\_or\_exit\_on\_errorv(ctx, 1, s, ap);
87   va\_end(ap);
88 \}
89 
90 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
91                                   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
92   va\_list ap;
93 
94   va\_start(ap, s);
95   warn\_or\_exit\_on\_errorv(ctx, fatal, s, ap);
96   va\_end(ap);
97 \}
98 
99 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxInputContext *input\_ctx, \hyperlink{structaom__image}{aom\_image\_t} *img) \{
100   FILE *f = input\_ctx->file;
101   y4m\_input *y4m = &input\_ctx->y4m;
102   \textcolor{keywordtype}{int} shortread = 0;
103 
104   \textcolor{keywordflow}{if} (input\_ctx->file\_type == FILE\_TYPE\_Y4M) \{
105     \textcolor{keywordflow}{if} (y4m\_input\_fetch\_frame(y4m, f, img) < 1) \textcolor{keywordflow}{return} 0;
106   \} \textcolor{keywordflow}{else} \{
107     shortread = read\_yuv\_frame(input\_ctx, img);
108   \}
109 
110   \textcolor{keywordflow}{return} !shortread;
111 \}
112 
113 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_y4m(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
114   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"YUV4"}, 4) == 0) \{
115     \textcolor{keywordflow}{return} 1;
116   \}
117   \textcolor{keywordflow}{return} 0;
118 \}
119 
120 \textcolor{keyword}{static} \textcolor{keywordtype}{int} fourcc\_is\_ivf(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
121   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"DKIF"}, 4) == 0) \{
122     \textcolor{keywordflow}{return} 1;
123   \}
124   \textcolor{keywordflow}{return} 0;
125 \}
126 
127 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
128     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
129 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t debugmode =
130     ARG\_DEF(\textcolor{stringliteral}{"D"}, \textcolor{stringliteral}{"debug"}, 0, \textcolor{stringliteral}{"Debug mode (makes output deterministic)"});
131 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
132     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output filename"});
133 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
134     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Input file is YV12 "});
135 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
136     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Input file is I420 (default)"});
137 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i422 =
138     ARG\_DEF(NULL, \textcolor{stringliteral}{"i422"}, 0, \textcolor{stringliteral}{"Input file is I422"});
139 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i444 =
140     ARG\_DEF(NULL, \textcolor{stringliteral}{"i444"}, 0, \textcolor{stringliteral}{"Input file is I444"});
141 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
142 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t passes =
143     ARG\_DEF(\textcolor{stringliteral}{"p"}, \textcolor{stringliteral}{"passes"}, 1, \textcolor{stringliteral}{"Number of passes (1/2)"});
144 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pass\_arg =
145     ARG\_DEF(NULL, \textcolor{stringliteral}{"pass"}, 1, \textcolor{stringliteral}{"Pass to execute (1/2)"});
146 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpf\_name =
147     ARG\_DEF(NULL, \textcolor{stringliteral}{"fpf"}, 1, \textcolor{stringliteral}{"First pass statistics file name"});
148 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
149 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpmbf\_name =
150     ARG\_DEF(NULL, \textcolor{stringliteral}{"fpmbf"}, 1, \textcolor{stringliteral}{"First pass block statistics file name"});
151 \textcolor{preprocessor}{#endif}
152 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limit =
153     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop encoding after n input frames"});
154 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skip =
155     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
156 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t good\_dl =
157     ARG\_DEF(NULL, \textcolor{stringliteral}{"good"}, 0, \textcolor{stringliteral}{"Use Good Quality Deadline"});
158 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t quietarg =
159     ARG\_DEF(\textcolor{stringliteral}{"q"}, \textcolor{stringliteral}{"quiet"}, 0, \textcolor{stringliteral}{"Do not print encode progress"});
160 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
161     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show encoder parameters"});
162 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t psnrarg =
163     ARG\_DEF(NULL, \textcolor{stringliteral}{"psnr"}, 0, \textcolor{stringliteral}{"Show PSNR in status line"});
164 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
165 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_cfg = ARG\_DEF(\textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"cfg"}, 1, \textcolor{stringliteral}{"Config file to use"});
166 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t ext\_partition =
167     ARG\_DEF(NULL, \textcolor{stringliteral}{"ext-partition"}, 1, \textcolor{stringliteral}{"corresponds to extended partitions"});
168 \textcolor{preprocessor}{#endif}
169 
170 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list test\_decode\_enum[] = \{
171   \{ \textcolor{stringliteral}{"off"}, TEST\_DECODE\_OFF \},
172   \{ \textcolor{stringliteral}{"fatal"}, TEST\_DECODE\_FATAL \},
173   \{ \textcolor{stringliteral}{"warn"}, TEST\_DECODE\_WARN \},
174   \{ NULL, 0 \}
175 \};
176 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t recontest = ARG\_DEF\_ENUM(
177     NULL, \textcolor{stringliteral}{"test-decode"}, 1, \textcolor{stringliteral}{"Test encode/decode mismatch"}, test\_decode\_enum);
178 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framerate =
179     ARG\_DEF(NULL, \textcolor{stringliteral}{"fps"}, 1, \textcolor{stringliteral}{"Stream frame rate (rate/scale)"});
180 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_webm =
181     ARG\_DEF(NULL, \textcolor{stringliteral}{"webm"}, 0, \textcolor{stringliteral}{"Output WebM (default when WebM IO is enabled)"});
182 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_ivf = ARG\_DEF(NULL, \textcolor{stringliteral}{"ivf"}, 0, \textcolor{stringliteral}{"Output IVF"});
183 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_obu = ARG\_DEF(NULL, \textcolor{stringliteral}{"obu"}, 0, \textcolor{stringliteral}{"Output OBU"});
184 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t out\_part =
185     ARG\_DEF(\textcolor{stringliteral}{"P"}, \textcolor{stringliteral}{"output-partitions"}, 0,
186             \textcolor{stringliteral}{"Makes encoder output partitions. Requires IVF output!"});
187 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t q\_hist\_n =
188     ARG\_DEF(NULL, \textcolor{stringliteral}{"q-hist"}, 1, \textcolor{stringliteral}{"Show quantizer histogram (n-buckets)"});
189 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rate\_hist\_n =
190     ARG\_DEF(NULL, \textcolor{stringliteral}{"rate-hist"}, 1, \textcolor{stringliteral}{"Show rate histogram (n-buckets)"});
191 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warnings =
192     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-warnings"}, 0,
193             \textcolor{stringliteral}{"Disable warnings about potentially incorrect encode settings."});
194 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warning\_prompt =
195     ARG\_DEF(\textcolor{stringliteral}{"y"}, \textcolor{stringliteral}{"disable-warning-prompt"}, 0,
196             \textcolor{stringliteral}{"Display warnings, but do not prompt user to continue."});
197 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list bitdepth\_enum[] = \{
198   \{ \textcolor{stringliteral}{"8"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} \}, \{ \textcolor{stringliteral}{"10"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a91734384f432233c3d681052122ab8e7}{AOM\_BITS\_10} \}, \{ \textcolor{stringliteral}{"12"}, 
      \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a15836a87f9e9940885d5ef59a52bf728}{AOM\_BITS\_12} \}, \{ NULL, 0 \}
199 \};
200 
201 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bitdeptharg = ARG\_DEF\_ENUM(
202     \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"bit-depth"}, 1,
203     \textcolor{stringliteral}{"Bit depth for codec (8 for version <=1, 10 or 12 for version 2)"},
204     bitdepth\_enum);
205 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t inbitdeptharg =
206     ARG\_DEF(NULL, \textcolor{stringliteral}{"input-bit-depth"}, 1, \textcolor{stringliteral}{"Bit depth of input"});
207 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *main\_args[] = \{ &help,
208 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
209                                         &use\_cfg,
210 \textcolor{preprocessor}{#endif}
211                                         &debugmode,
212                                         &outputfile,
213                                         &codecarg,
214                                         &passes,
215                                         &pass\_arg,
216                                         &fpf\_name,
217                                         &limit,
218                                         &skip,
219                                         &good\_dl,
220                                         &quietarg,
221                                         &verbosearg,
222                                         &psnrarg,
223                                         &use\_webm,
224                                         &use\_ivf,
225                                         &use\_obu,
226                                         &out\_part,
227                                         &q\_hist\_n,
228                                         &rate\_hist\_n,
229                                         &disable\_warnings,
230                                         &disable\_warning\_prompt,
231                                         &recontest,
232                                         NULL \};
233 
234 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t usage =
235     ARG\_DEF(\textcolor{stringliteral}{"u"}, \textcolor{stringliteral}{"usage"}, 1, \textcolor{stringliteral}{"Usage profile number to use"});
236 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threads =
237     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max number of threads to use"});
238 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t profile =
239     ARG\_DEF(NULL, \textcolor{stringliteral}{"profile"}, 1, \textcolor{stringliteral}{"Bitstream profile number to use"});
240 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t width = ARG\_DEF(\textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"width"}, 1, \textcolor{stringliteral}{"Frame width"});
241 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t height = ARG\_DEF(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{"height"}, 1, \textcolor{stringliteral}{"Frame height"});
242 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_width = ARG\_DEF(
243     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_width"}, 0, \textcolor{stringliteral}{"Maximum frame width value to force"});
244 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_height = ARG\_DEF(
245     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_height"}, 0, \textcolor{stringliteral}{"Maximum frame height value to force"});
246 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
247 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list stereo\_mode\_enum[] = \{
248   \{ \textcolor{stringliteral}{"mono"}, STEREO\_FORMAT\_MONO \},
249   \{ \textcolor{stringliteral}{"left-right"}, STEREO\_FORMAT\_LEFT\_RIGHT \},
250   \{ \textcolor{stringliteral}{"bottom-top"}, STEREO\_FORMAT\_BOTTOM\_TOP \},
251   \{ \textcolor{stringliteral}{"top-bottom"}, STEREO\_FORMAT\_TOP\_BOTTOM \},
252   \{ \textcolor{stringliteral}{"right-left"}, STEREO\_FORMAT\_RIGHT\_LEFT \},
253   \{ NULL, 0 \}
254 \};
255 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t stereo\_mode = ARG\_DEF\_ENUM(
256     NULL, \textcolor{stringliteral}{"stereo-mode"}, 1, \textcolor{stringliteral}{"Stereo 3D video format"}, stereo\_mode\_enum);
257 \textcolor{preprocessor}{#endif}
258 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timebase = ARG\_DEF(
259     NULL, \textcolor{stringliteral}{"timebase"}, 1, \textcolor{stringliteral}{"Output timestamp precision (fractional seconds)"});
260 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t global\_error\_resilient =
261     ARG\_DEF(NULL, \textcolor{stringliteral}{"global-error-resilient"}, 1,
262             \textcolor{stringliteral}{"Enable global error resiliency features"});
263 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lag\_in\_frames =
264     ARG\_DEF(NULL, \textcolor{stringliteral}{"lag-in-frames"}, 1, \textcolor{stringliteral}{"Max number of frames to lag"});
265 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t large\_scale\_tile =
266     ARG\_DEF(NULL, \textcolor{stringliteral}{"large-scale-tile"}, 1,
267             \textcolor{stringliteral}{"Large scale tile coding (0: off (default), 1: on)"});
268 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t monochrome =
269     ARG\_DEF(NULL, \textcolor{stringliteral}{"monochrome"}, 0, \textcolor{stringliteral}{"Monochrome video (no chroma planes)"});
270 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t full\_still\_picture\_hdr = ARG\_DEF(
271     NULL, \textcolor{stringliteral}{"full-still-picture-hdr"}, 0, \textcolor{stringliteral}{"Use full header for still picture"});
272 
273 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *global\_args[] = \{ &use\_yv12,
274                                           &use\_i420,
275                                           &use\_i422,
276                                           &use\_i444,
277                                           &usage,
278                                           &threads,
279                                           &profile,
280                                           &width,
281                                           &height,
282                                           &forced\_max\_frame\_width,
283                                           &forced\_max\_frame\_height,
284 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
285                                           &stereo\_mode,
286 \textcolor{preprocessor}{#endif}
287                                           &timebase,
288                                           &framerate,
289                                           &global\_error\_resilient,
290                                           &bitdeptharg,
291                                           &lag\_in\_frames,
292                                           &large\_scale\_tile,
293                                           &monochrome,
294                                           &full\_still\_picture\_hdr,
295                                           NULL \};
296 
297 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t dropframe\_thresh =
298     ARG\_DEF(NULL, \textcolor{stringliteral}{"drop-frame"}, 1, \textcolor{stringliteral}{"Temporal resampling threshold (buf %)"});
299 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_mode =
300     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-mode"}, 1, \textcolor{stringliteral}{"Frame resize mode"});
301 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_denominator =
302     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-denominator"}, 1, \textcolor{stringliteral}{"Frame resize denominator"});
303 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_kf\_denominator = ARG\_DEF(
304     NULL, \textcolor{stringliteral}{"resize-kf-denominator"}, 1, \textcolor{stringliteral}{"Frame resize keyframe denominator"});
305 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_mode =
306     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-mode"}, 1, \textcolor{stringliteral}{"Frame super-resolution mode"});
307 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_denominator = ARG\_DEF(
308     NULL, \textcolor{stringliteral}{"superres-denominator"}, 1, \textcolor{stringliteral}{"Frame super-resolution denominator"});
309 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_denominator =
310     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-denominator"}, 1,
311             \textcolor{stringliteral}{"Frame super-resolution keyframe denominator"});
312 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_qthresh = ARG\_DEF(
313     NULL, \textcolor{stringliteral}{"superres-qthresh"}, 1, \textcolor{stringliteral}{"Frame super-resolution qindex threshold"});
314 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_qthresh =
315     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-qthresh"}, 1,
316             \textcolor{stringliteral}{"Frame super-resolution keyframe qindex threshold"});
317 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list end\_usage\_enum[] = \{ \{ \textcolor{stringliteral}{"vbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a7d3a2574737ea63d0f160ffdbd7f0110}{AOM\_VBR} \},
318                                                        \{ \textcolor{stringliteral}{"cbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a14b6057d61c61e6117f5af16dcf89b0c}{AOM\_CBR} \},
319                                                        \{ \textcolor{stringliteral}{"cq"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a70aa1f15e91f6576ba3e63879947be64}{AOM\_CQ} \},
320                                                        \{ \textcolor{stringliteral}{"q"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q} \},
321                                                        \{ NULL, 0 \} \};
322 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t end\_usage =
323     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"end-usage"}, 1, \textcolor{stringliteral}{"Rate control mode"}, end\_usage\_enum);
324 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t target\_bitrate =
325     ARG\_DEF(NULL, \textcolor{stringliteral}{"target-bitrate"}, 1, \textcolor{stringliteral}{"Bitrate (kbps)"});
326 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_quantizer =
327     ARG\_DEF(NULL, \textcolor{stringliteral}{"min-q"}, 1, \textcolor{stringliteral}{"Minimum (best) quantizer"});
328 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_quantizer =
329     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-q"}, 1, \textcolor{stringliteral}{"Maximum (worst) quantizer"});
330 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t undershoot\_pct =
331     ARG\_DEF(NULL, \textcolor{stringliteral}{"undershoot-pct"}, 1, \textcolor{stringliteral}{"Datarate undershoot (min) target (%)"});
332 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t overshoot\_pct =
333     ARG\_DEF(NULL, \textcolor{stringliteral}{"overshoot-pct"}, 1, \textcolor{stringliteral}{"Datarate overshoot (max) target (%)"});
334 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_sz =
335     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-sz"}, 1, \textcolor{stringliteral}{"Client buffer size (ms)"});
336 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_initial\_sz =
337     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-initial-sz"}, 1, \textcolor{stringliteral}{"Client initial buffer size (ms)"});
338 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_optimal\_sz =
339     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-optimal-sz"}, 1, \textcolor{stringliteral}{"Client optimal buffer size (ms)"});
340 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_args[] = \{ &dropframe\_thresh,
341                                       &resize\_mode,
342                                       &resize\_denominator,
343                                       &resize\_kf\_denominator,
344                                       &superres\_mode,
345                                       &superres\_denominator,
346                                       &superres\_kf\_denominator,
347                                       &superres\_qthresh,
348                                       &superres\_kf\_qthresh,
349                                       &end\_usage,
350                                       &target\_bitrate,
351                                       &min\_quantizer,
352                                       &max\_quantizer,
353                                       &undershoot\_pct,
354                                       &overshoot\_pct,
355                                       &buf\_sz,
356                                       &buf\_initial\_sz,
357                                       &buf\_optimal\_sz,
358                                       NULL \};
359 
360 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bias\_pct =
361     ARG\_DEF(NULL, \textcolor{stringliteral}{"bias-pct"}, 1, \textcolor{stringliteral}{"CBR/VBR bias (0=CBR, 100=VBR)"});
362 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t minsection\_pct =
363     ARG\_DEF(NULL, \textcolor{stringliteral}{"minsection-pct"}, 1, \textcolor{stringliteral}{"GOP min bitrate (% of target)"});
364 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t maxsection\_pct =
365     ARG\_DEF(NULL, \textcolor{stringliteral}{"maxsection-pct"}, 1, \textcolor{stringliteral}{"GOP max bitrate (% of target)"});
366 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_twopass\_args[] = \{ &bias\_pct, &minsection\_pct,
367                                               &maxsection\_pct, NULL \};
368 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fwd\_kf\_enabled =
369     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-fwd-kf"}, 1, \textcolor{stringliteral}{"Enable forward reference keyframes"});
370 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_min\_dist =
371     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-min-dist"}, 1, \textcolor{stringliteral}{"Minimum keyframe interval (frames)"});
372 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_max\_dist =
373     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-max-dist"}, 1, \textcolor{stringliteral}{"Maximum keyframe interval (frames)"});
374 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_disabled =
375     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-kf"}, 0, \textcolor{stringliteral}{"Disable keyframe placement"});
376 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *kf\_args[] = \{ &fwd\_kf\_enabled, &kf\_min\_dist,
377                                       &kf\_max\_dist, &kf\_disabled, NULL \};
378 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_dist =
379     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-dist"}, 1, \textcolor{stringliteral}{"S-Frame interval (frames)"});
380 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_mode =
381     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-mode"}, 1, \textcolor{stringliteral}{"S-Frame insertion mode (1..2)"});
382 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t save\_as\_annexb =
383     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 1, \textcolor{stringliteral}{"Save as Annex-B"});
384 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noise\_sens =
385     ARG\_DEF(NULL, \textcolor{stringliteral}{"noise-sensitivity"}, 1, \textcolor{stringliteral}{"Noise sensitivity (frames to blur)"});
386 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sharpness =
387     ARG\_DEF(NULL, \textcolor{stringliteral}{"sharpness"}, 1, \textcolor{stringliteral}{"Loop filter sharpness (0..7)"});
388 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t static\_thresh =
389     ARG\_DEF(NULL, \textcolor{stringliteral}{"static-thresh"}, 1, \textcolor{stringliteral}{"Motion detection threshold"});
390 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t auto\_altref =
391     ARG\_DEF(NULL, \textcolor{stringliteral}{"auto-alt-ref"}, 1, \textcolor{stringliteral}{"Enable automatic alt reference frames"});
392 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_maxframes =
393     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-maxframes"}, 1, \textcolor{stringliteral}{"AltRef max frames (0..15)"});
394 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_strength =
395     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-strength"}, 1, \textcolor{stringliteral}{"AltRef filter strength (0..6)"});
396 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tuning\_enum[] = \{
397   \{ \textcolor{stringliteral}{"psnr"}, AOM\_TUNE\_PSNR \},
398   \{ \textcolor{stringliteral}{"ssim"}, AOM\_TUNE\_SSIM \},
399 \textcolor{preprocessor}{#ifdef CONFIG\_DIST\_8X8}
400   \{ \textcolor{stringliteral}{"cdef-dist"}, AOM\_TUNE\_CDEF\_DIST \},
401   \{ \textcolor{stringliteral}{"daala-dist"}, AOM\_TUNE\_DAALA\_DIST \},
402 \textcolor{preprocessor}{#endif}
403   \{ NULL, 0 \}
404 \};
405 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_metric =
406     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"tune"}, 1, \textcolor{stringliteral}{"Distortion metric tuned with"}, tuning\_enum);
407 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cq\_level =
408     ARG\_DEF(NULL, \textcolor{stringliteral}{"cq-level"}, 1, \textcolor{stringliteral}{"Constant/Constrained Quality level"});
409 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_intra\_rate\_pct =
410     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-intra-rate"}, 1, \textcolor{stringliteral}{"Max I-frame bitrate (pct)"});
411 
412 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
413 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cpu\_used\_av1 =
414     ARG\_DEF(NULL, \textcolor{stringliteral}{"cpu-used"}, 1, \textcolor{stringliteral}{"CPU Used (0..8)"});
415 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t dev\_sf\_av1 =
416     ARG\_DEF(NULL, \textcolor{stringliteral}{"dev-sf"}, 1, \textcolor{stringliteral}{"Dev Speed (0..255)"});
417 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t single\_tile\_decoding =
418     ARG\_DEF(NULL, \textcolor{stringliteral}{"single-tile-decoding"}, 1,
419             \textcolor{stringliteral}{"Single tile decoding (0: off (default), 1: on)"});
420 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_cols =
421     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-columns"}, 1, \textcolor{stringliteral}{"Number of tile columns to use, log2"});
422 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_rows =
423     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-rows"}, 1,
424             \textcolor{stringliteral}{"Number of tile rows to use, log2 (set to 0 while threads > 1)"});
425 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_width =
426     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-width"}, 1, \textcolor{stringliteral}{"Tile widths (comma separated)"});
427 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_height =
428     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-height"}, 1, \textcolor{stringliteral}{"Tile heights (command separated)"});
429 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lossless =
430     ARG\_DEF(NULL, \textcolor{stringliteral}{"lossless"}, 1, \textcolor{stringliteral}{"Lossless mode (0: false (default), 1: true)"});
431 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_cdef =
432     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-cdef"}, 1,
433             \textcolor{stringliteral}{"Enable the constrained directional enhancement filter (0: false, "}
434             \textcolor{stringliteral}{"1: true (default))"});
435 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_restoration =
436     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-restoration"}, 1,
437             \textcolor{stringliteral}{"Enable the loop restoration filter (0: false, "}
438             \textcolor{stringliteral}{"1: true (default))"});
439 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_trellis\_quant =
440     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-trellis-quant"}, 1,
441             \textcolor{stringliteral}{"Disable trellis optimization of quantized coefficients (0: false ("}
442             \textcolor{stringliteral}{"default) 1: true)"});
443 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_qm =
444     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-qm"}, 1,
445             \textcolor{stringliteral}{"Enable quantisation matrices (0: false (default), 1: true)"});
446 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_min = ARG\_DEF(
447     NULL, \textcolor{stringliteral}{"qm-min"}, 1, \textcolor{stringliteral}{"Min quant matrix flatness (0..15), default is 8"});
448 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_max = ARG\_DEF(
449     NULL, \textcolor{stringliteral}{"qm-max"}, 1, \textcolor{stringliteral}{"Max quant matrix flatness (0..15), default is 15"});
450 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
451 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dist\_8x8 =
452     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dist-8x8"}, 1,
453             \textcolor{stringliteral}{"Enable dist-8x8 (0: false (default), 1: true)"});
454 \textcolor{preprocessor}{#endif  // CONFIG\_DIST\_8X8}
455 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t num\_tg = ARG\_DEF(
456     NULL, \textcolor{stringliteral}{"num-tile-groups"}, 1, \textcolor{stringliteral}{"Maximum number of tile groups, default is 1"});
457 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t mtu\_size =
458     ARG\_DEF(NULL, \textcolor{stringliteral}{"mtu-size"}, 1,
459             \textcolor{stringliteral}{"MTU size for a tile group, default is 0 (no MTU targeting), "}
460             \textcolor{stringliteral}{"overrides maximum number of tile groups"});
461 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list timing\_info\_enum[] = \{
462   \{ \textcolor{stringliteral}{"unspecified"}, AOM\_TIMING\_UNSPECIFIED \},
463   \{ \textcolor{stringliteral}{"constant"}, AOM\_TIMING\_EQUAL \},
464   \{ \textcolor{stringliteral}{"model"}, AOM\_TIMING\_DEC\_MODEL \},
465   \{ NULL, 0 \}
466 \};
467 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timing\_info =
468     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"timing-info"}, 1,
469                  \textcolor{stringliteral}{"Signal timing info in the bitstream (model unly works for no "}
470                  \textcolor{stringliteral}{"hidden frames, no super-res yet):"},
471                  timing\_info\_enum);
472 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_test =
473     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-test"}, 1,
474             \textcolor{stringliteral}{"Film grain test vectors (0: none (default), 1: test-1  2: test-2, "}
475             \textcolor{stringliteral}{"... 16: test-16)"});
476 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_table =
477     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-table"}, 1,
478             \textcolor{stringliteral}{"Path to file containing film grain parameters"});
479 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_ref\_frame\_mvs =
480     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-ref-frame-mvs"}, 1,
481             \textcolor{stringliteral}{"Enable temporal mv prediction (default is 1)"});
482 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_parallel\_decoding =
483     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-parallel"}, 1,
484             \textcolor{stringliteral}{"Enable frame parallel decodability features "}
485             \textcolor{stringliteral}{"(0: false (default), 1: true)"});
486 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t error\_resilient\_mode =
487     ARG\_DEF(NULL, \textcolor{stringliteral}{"error-resilient"}, 1,
488             \textcolor{stringliteral}{"Enable error resilient features "}
489             \textcolor{stringliteral}{"(0: false (default), 1: true)"});
490 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t aq\_mode = ARG\_DEF(
491     NULL, \textcolor{stringliteral}{"aq-mode"}, 1,
492     \textcolor{stringliteral}{"Adaptive quantization mode (0: off (default), 1: variance 2: complexity, "}
493     \textcolor{stringliteral}{"3: cyclic refresh)"});
494 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t deltaq\_mode = ARG\_DEF(
495     NULL, \textcolor{stringliteral}{"deltaq-mode"}, 1,
496     \textcolor{stringliteral}{"Delta qindex mode (0: off (default), 1: deltaq 2: deltaq + deltalf)"});
497 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_periodic\_boost =
498     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-boost"}, 1,
499             \textcolor{stringliteral}{"Enable frame periodic boost (0: off (default), 1: on)"});
500 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t gf\_cbr\_boost\_pct = ARG\_DEF(
501     NULL, \textcolor{stringliteral}{"gf-cbr-boost"}, 1, \textcolor{stringliteral}{"Boost for Golden Frame in CBR mode (pct)"});
502 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_inter\_rate\_pct =
503     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-inter-rate"}, 1, \textcolor{stringliteral}{"Max P-frame bitrate (pct)"});
504 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_gf\_interval = ARG\_DEF(
505     NULL, \textcolor{stringliteral}{"min-gf-interval"}, 1,
506     \textcolor{stringliteral}{"min gf/arf frame interval (default 0, indicating in-built behavior)"});
507 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_gf\_interval = ARG\_DEF(
508     NULL, \textcolor{stringliteral}{"max-gf-interval"}, 1,
509     \textcolor{stringliteral}{"max gf/arf frame interval (default 0, indicating in-built behavior)"});
510 
511 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list color\_primaries\_enum[] = \{
512   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9a2ebe055c0508a2a2f72b6c192fcce9}{AOM\_CICP\_CP\_BT\_709} \},
513   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
514   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa3ce81eb125550ec2f11a58f183eeaee6}{AOM\_CICP\_CP\_BT\_601} \},
515   \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa5b57cb26f04f4df6585335129392d5e2}{AOM\_CICP\_CP\_BT\_470\_M} \},
516   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8b33dc8483c16048c606d75d9f11e38a}{AOM\_CICP\_CP\_BT\_470\_B\_G} \},
517   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
518   \{ \textcolor{stringliteral}{"film"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8dd6ba5106c22d149a233e73232aeb65}{AOM\_CICP\_CP\_GENERIC\_FILM} \},
519   \{ \textcolor{stringliteral}{"bt2020"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6bb95baf09cd6e1f3596b459712c592a}{AOM\_CICP\_CP\_BT\_2020} \},
520   \{ \textcolor{stringliteral}{"xyz"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6032cae72a729933a6a75e3b943a542c}{AOM\_CICP\_CP\_XYZ} \},
521   \{ \textcolor{stringliteral}{"smpte431"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa54d519c9ac0ca52ebda7caf736530e57}{AOM\_CICP\_CP\_SMPTE\_431} \},
522   \{ \textcolor{stringliteral}{"smpte432"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa227b6e4116ed0266af20b705aebaf661}{AOM\_CICP\_CP\_SMPTE\_432} \},
523   \{ \textcolor{stringliteral}{"ebu3213"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9e74dcb338953bfab3101aa33ea44157}{AOM\_CICP\_CP\_EBU\_3213} \},
524   \{ NULL, 0 \}
525 \};
526 
527 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_color\_primaries = ARG\_DEF\_ENUM(
528     NULL, \textcolor{stringliteral}{"color-primaries"}, 1,
529     \textcolor{stringliteral}{"Color primaries (CICP) of input content:"}, color\_primaries\_enum);
530 
531 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list transfer\_characteristics\_enum[] = \{
532   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
533   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992affe340e422646b7d70ef91edd6a8053c}{AOM\_CICP\_TC\_BT\_709} \},
534   \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a356d6943d11d88e7a42370c1c698c214}{AOM\_CICP\_TC\_BT\_470\_M} \},
535   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7a347c6d5605db0a6ee89cc81dec0b37}{AOM\_CICP\_TC\_BT\_470\_B\_G} \},
536   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a5b51bfcf0f3779a7d907ac45ee4067a4}{AOM\_CICP\_TC\_BT\_601} \},
537   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac3b5e95e3400830c334268fca69a1226}{AOM\_CICP\_TC\_SMPTE\_240} \},
538   \{ \textcolor{stringliteral}{"lin"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a99ebdb0b1a35e0bf25808f851aa80a35}{AOM\_CICP\_TC\_LINEAR} \},
539   \{ \textcolor{stringliteral}{"log100"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a54ec8cfad46215d855696bafe371ffe1}{AOM\_CICP\_TC\_LOG\_100} \},
540   \{ \textcolor{stringliteral}{"log100sq10"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7d79c257042a5958bafa6b5ccfbd96cb}{AOM\_CICP\_TC\_LOG\_100\_SQRT10} \},
541   \{ \textcolor{stringliteral}{"iec61966"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a57f92f410badf8a43b19df18edc9b8b9}{AOM\_CICP\_TC\_IEC\_61966} \},
542   \{ \textcolor{stringliteral}{"bt1361"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac60ca749a2d0ca1c860d82f0825a3e2d}{AOM\_CICP\_TC\_BT\_1361} \},
543   \{ \textcolor{stringliteral}{"srgb"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a94553e773e3d3fb005236ed70eeedfea}{AOM\_CICP\_TC\_SRGB} \},
544   \{ \textcolor{stringliteral}{"bt2020-10bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a1ce5fbca5277266680d70bb7211646d6}{AOM\_CICP\_TC\_BT\_2020\_10\_BIT} \},
545   \{ \textcolor{stringliteral}{"bt2020-12bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992afcc74c6858aefc13c426dd6992198e75}{AOM\_CICP\_TC\_BT\_2020\_12\_BIT} \},
546   \{ \textcolor{stringliteral}{"smpte2084"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ab48fdcc8c2c0350f6423b9c116c1876d}{AOM\_CICP\_TC\_SMPTE\_2084} \},
547   \{ \textcolor{stringliteral}{"hlg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a3d7b83c425c539d1a36fb36e9aebf268}{AOM\_CICP\_TC\_HLG} \},
548   \{ \textcolor{stringliteral}{"smpte428"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a45df590313483af0c614708f346028c4}{AOM\_CICP\_TC\_SMPTE\_428} \},
549   \{ NULL, 0 \}
550 \};
551 
552 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_transfer\_characteristics =
553     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"transfer-characteristics"}, 1,
554                  \textcolor{stringliteral}{"Transfer characteristics (CICP) of input content:"},
555                  transfer\_characteristics\_enum);
556 
557 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list matrix\_coefficients\_enum[] = \{
558   \{ \textcolor{stringliteral}{"identity"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a17489bf0aed544427f7c6bbe4837b212}{AOM\_CICP\_MC\_IDENTITY} \},
559   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa70fd9b88bc91bd0d126aaa07421c49a}{AOM\_CICP\_MC\_BT\_709} \},
560   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a06a4defb1e5d9bb1d2aad092b8656a03}{AOM\_CICP\_MC\_UNSPECIFIED} \},
561   \{ \textcolor{stringliteral}{"fcc73"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae368663c2c2f34683b513e159c5738b9}{AOM\_CICP\_MC\_FCC} \},
562   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae9107262b437659514abdcd928e977db}{AOM\_CICP\_MC\_BT\_470\_B\_G} \},
563   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a0f81310501079cc1184d5265ae2c18a5}{AOM\_CICP\_MC\_BT\_601} \},
564   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
565   \{ \textcolor{stringliteral}{"ycgco"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa2140164b26b42404c376cc921ce27c5}{AOM\_CICP\_MC\_SMPTE\_YCGCO} \},
566   \{ \textcolor{stringliteral}{"bt2020ncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081adf60aa79c6a68f4eb41e1095f8bf7bf6}{AOM\_CICP\_MC\_BT\_2020\_NCL} \},
567   \{ \textcolor{stringliteral}{"bt2020cl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a34148eae7b467eece6af5c90405dde6b}{AOM\_CICP\_MC\_BT\_2020\_CL} \},
568   \{ \textcolor{stringliteral}{"smpte2085"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a3aeb0ed0afc0a92ce758f109cd05ee80}{AOM\_CICP\_MC\_SMPTE\_2085} \},
569   \{ \textcolor{stringliteral}{"chromncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a30661e9d9b70ffe9f51f3bdbfd02865b}{AOM\_CICP\_MC\_CHROMAT\_NCL} \},
570   \{ \textcolor{stringliteral}{"chromcl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa391f9255e4775da0120f7472b417193}{AOM\_CICP\_MC\_CHROMAT\_CL} \},
571   \{ \textcolor{stringliteral}{"ictcp"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a7695b0577d3884a89c578f28f4237aee}{AOM\_CICP\_MC\_ICTCP} \},
572   \{ NULL, 0 \}
573 \};
574 
575 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_matrix\_coefficients = ARG\_DEF\_ENUM(
576     NULL, \textcolor{stringliteral}{"matrix-coefficients"}, 1,
577     \textcolor{stringliteral}{"Matrix coefficients (CICP) of input content:"}, matrix\_coefficients\_enum);
578 
579 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list chroma\_sample\_position\_enum[] = \{
580   \{ \textcolor{stringliteral}{"unknown"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba7843506f3e28f720be0d4f03237fb48c}{AOM\_CSP\_UNKNOWN} \},
581   \{ \textcolor{stringliteral}{"vertical"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73baf95ced9b8288642205301cc51e0b55c6}{AOM\_CSP\_VERTICAL} \},
582   \{ \textcolor{stringliteral}{"colocated"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba01ef7204c2234ef43acfd493d5e18c84}{AOM\_CSP\_COLOCATED} \},
583   \{ NULL, 0 \}
584 \};
585 
586 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_sample\_position =
587     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"chroma-sample-position"}, 1,
588                  \textcolor{stringliteral}{"The chroma sample position when chroma 4:2:0 is signaled:"},
589                  chroma\_sample\_position\_enum);
590 
591 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tune\_content\_enum[] = \{
592   \{ \textcolor{stringliteral}{"default"}, AOM\_CONTENT\_DEFAULT \},
593   \{ \textcolor{stringliteral}{"screen"}, AOM\_CONTENT\_SCREEN \},
594   \{ NULL, 0 \}
595 \};
596 
597 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_content = ARG\_DEF\_ENUM(
598     NULL, \textcolor{stringliteral}{"tune-content"}, 1, \textcolor{stringliteral}{"Tune content type"}, tune\_content\_enum);
599 
600 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cdf\_update\_mode =
601     ARG\_DEF(NULL, \textcolor{stringliteral}{"cdf-update-mode"}, 1,
602             \textcolor{stringliteral}{"CDF update mode for entropy coding "}
603             \textcolor{stringliteral}{"(0: no CDF update; 1: update CDF on all frames(default); "}
604             \textcolor{stringliteral}{"2: selectively update CDF on some frames"});
605 
606 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list superblock\_size\_enum[] = \{
607   \{ \textcolor{stringliteral}{"dynamic"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61aaabb4d9ad771b2fa177ff6fb5437b179}{AOM\_SUPERBLOCK\_SIZE\_DYNAMIC} \},
608   \{ \textcolor{stringliteral}{"64"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64} \},
609   \{ \textcolor{stringliteral}{"128"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a17127133dafcd42b1d792770981d67d0}{AOM\_SUPERBLOCK\_SIZE\_128X128} \},
610   \{ NULL, 0 \}
611 \};
612 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superblock\_size = ARG\_DEF\_ENUM(
613     NULL, \textcolor{stringliteral}{"sb-size"}, 1, \textcolor{stringliteral}{"Superblock size to use"}, superblock\_size\_enum);
614 
615 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *av1\_args[] = \{ &cpu\_used\_av1,
616                                        &dev\_sf\_av1,
617                                        &auto\_altref,
618                                        &sharpness,
619                                        &static\_thresh,
620                                        &single\_tile\_decoding,
621                                        &tile\_cols,
622                                        &tile\_rows,
623                                        &arnr\_maxframes,
624                                        &arnr\_strength,
625                                        &tune\_metric,
626                                        &cq\_level,
627                                        &max\_intra\_rate\_pct,
628                                        &max\_inter\_rate\_pct,
629                                        &gf\_cbr\_boost\_pct,
630                                        &lossless,
631                                        &enable\_cdef,
632                                        &enable\_restoration,
633                                        &disable\_trellis\_quant,
634                                        &enable\_qm,
635                                        &qm\_min,
636                                        &qm\_max,
637 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
638                                        &enable\_dist\_8x8,
639 \textcolor{preprocessor}{#endif}
640                                        &frame\_parallel\_decoding,
641                                        &error\_resilient\_mode,
642                                        &aq\_mode,
643                                        &deltaq\_mode,
644                                        &frame\_periodic\_boost,
645                                        &noise\_sens,
646                                        &tune\_content,
647                                        &cdf\_update\_mode,
648                                        &input\_color\_primaries,
649                                        &input\_transfer\_characteristics,
650                                        &input\_matrix\_coefficients,
651                                        &input\_chroma\_sample\_position,
652                                        &min\_gf\_interval,
653                                        &max\_gf\_interval,
654                                        &superblock\_size,
655                                        &num\_tg,
656                                        &mtu\_size,
657                                        &timing\_info,
658                                        &film\_grain\_test,
659                                        &film\_grain\_table,
660                                        &enable\_ref\_frame\_mvs,
661                                        &bitdeptharg,
662                                        &inbitdeptharg,
663                                        &sframe\_dist,
664                                        &sframe\_mode,
665                                        &save\_as\_annexb,
666                                        NULL \};
667 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} av1\_arg\_ctrl\_map[] = \{ \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED},
668                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abf617d10f7a053f0f29c8bbbf29ce0aa}{AOME\_SET\_DEVSF},
669                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF},
670                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0df0d30e82bb9683f3131138dfa2949a}{AOME\_SET\_SHARPNESS},
671                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa4f58f6a86b710e403daeac055738111}{AOME\_SET\_STATIC\_THRESHOLD},
672                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af341538631ffe2ac2b562c8b5336a10a}{AV1E\_SET\_SINGLE\_TILE\_DECODING},
673                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS},
674                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS},
675                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a327fb270f37bbb008b0f146542ce7483}{AOME\_SET\_ARNR\_MAXFRAMES},
676                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5affd2c213f24a12d13bb51e31be993e60}{AOME\_SET\_ARNR\_STRENGTH},
677                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aba539b6646278e7ff40f67f38639d294}{AOME\_SET\_TUNING},
678                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL},
679                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9e1965ffa40d2d87556b65748c63adcc}{AOME\_SET\_MAX\_INTRA\_BITRATE\_PCT},
680                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a54b7c950e51f39a3cb7344a2665b9929}{AV1E\_SET\_MAX\_INTER\_BITRATE\_PCT},
681                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ade327180f01d27d22abd94c1f0a8bc9e}{AV1E\_SET\_GF\_CBR\_BOOST\_PCT},
682                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS},
683                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a6879fe104e23de00f034ed11eb605031}{AV1E\_SET\_ENABLE\_CDEF},
684                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2ea70b4b379e701a4b3b7cc33eb05e65}{AV1E\_SET\_ENABLE\_RESTORATION},
685                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a374b5581d0b68d5f8cc3e3f73495cfbb}{AV1E\_SET\_DISABLE\_TRELLIS\_QUANT},
686                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae63993934cdc5aa36efeec4df87a577e}{AV1E\_SET\_ENABLE\_QM},
687                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae611944ba148b6446d4387dd9b452917}{AV1E\_SET\_QM\_MIN},
688                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad897674e1b68b24ec14a01a4e3edacc7}{AV1E\_SET\_QM\_MAX},
689 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
690                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a7ef16c780349c5fee8281f1e5b4a6718}{AV1E\_SET\_ENABLE\_DIST\_8X8},
691 \textcolor{preprocessor}{#endif}
692                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING},
693                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa0d049453fced5f8079861b16e356c69}{AV1E\_SET\_ERROR\_RESILIENT\_MODE},
694                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17bd297efc31082157785d68fc5a6067}{AV1E\_SET\_AQ\_MODE},
695                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad26eda6211bf3d5fe4f5999ec52b264b}{AV1E\_SET\_DELTAQ\_MODE},
696                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a737368591a37417b108c0706f7510885}{AV1E\_SET\_FRAME\_PERIODIC\_BOOST},
697                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8d415cd6976ea5860206e1d3cd3dd222}{AV1E\_SET\_NOISE\_SENSITIVITY},
698                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2625f566fd5c2675eb2bcd40af858652}{AV1E\_SET\_TUNE\_CONTENT},
699                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a277526a4a9b8c413e870ee17ff986e87}{AV1E\_SET\_CDF\_UPDATE\_MODE},
700                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af64e990728fe37287bac0874d77b22db}{AV1E\_SET\_COLOR\_PRIMARIES},
701                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a336fc3607a5987f9077c634f07b3cd53}{AV1E\_SET\_TRANSFER\_CHARACTERISTICS},
702                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0111ed659d2cd11827ac5cd1f3d774b0}{AV1E\_SET\_MATRIX\_COEFFICIENTS},
703                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc5bb5cf57ba1a1193a0593225e881ff}{AV1E\_SET\_CHROMA\_SAMPLE\_POSITION},
704                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a31bcfcb7057884ceb831146c90086ddd}{AV1E\_SET\_MIN\_GF\_INTERVAL},
705                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0355cea227ab76f9bd77028a39bbfca8}{AV1E\_SET\_MAX\_GF\_INTERVAL},
706                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
707                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG},
708                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a353037d84b6c47ac0138fa843b70a2bb}{AV1E\_SET\_MTU},
709                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a857e822046c62a4c774b1d16c4e453dd}{AV1E\_SET\_TIMING\_INFO\_TYPE},
710                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a437e6b282a2395b4b08a9acde3e41cfb}{AV1E\_SET\_FILM\_GRAIN\_TEST\_VECTOR},
711                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
712                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a5e82346d8463bf758967abb0d03ebc88}{AV1E\_SET\_ENABLE\_REF\_FRAME\_MVS},
713                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ab2a89e85539e97b96e057cb063063c86}{AV1E\_SET\_ENABLE\_DF},
714                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad0eaf349d653c8357acbba84ad95d5e6}{AV1E\_SET\_ENABLE\_ORDER\_HINT},
715                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac5c0c60dc1b709c082da28feae3bcad3}{AV1E\_SET\_ENABLE\_JNT\_COMP},
716                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a86e399de03aa825bb7e594e3df1bf71b}{AV1E\_SET\_ENABLE\_SUPERRES},
717                                         0 \};
718 \textcolor{preprocessor}{#endif  // CONFIG\_AV1\_ENCODER}
719 
720 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *no\_args[] = \{ NULL \};
721 
722 \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
723   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> -o dst\_filename src\_filename \(\backslash\)n"},
724           exec\_name);
725 
726   \textcolor{keywordflow}{if} (shorthelp) \{
727     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
728     \textcolor{keywordflow}{return};
729   \}
730 
731   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nOptions:\(\backslash\)n"});
732   arg\_show\_usage(fout, main\_args);
733   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nEncoder Global Options:\(\backslash\)n"});
734   arg\_show\_usage(fout, global\_args);
735   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nRate Control Options:\(\backslash\)n"});
736   arg\_show\_usage(fout, rc\_args);
737   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nTwopass Rate Control Options:\(\backslash\)n"});
738   arg\_show\_usage(fout, rc\_twopass\_args);
739   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nKeyframe Placement Options:\(\backslash\)n"});
740   arg\_show\_usage(fout, kf\_args);
741 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
742   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nAV1 Specific Options:\(\backslash\)n"});
743   arg\_show\_usage(fout, av1\_args);
744 \textcolor{preprocessor}{#endif}
745   fprintf(fout,
746           \textcolor{stringliteral}{"\(\backslash\)nStream timebase (--timebase):\(\backslash\)n"}
747           \textcolor{stringliteral}{"  The desired precision of timestamps in the output, expressed\(\backslash\)n"}
748           \textcolor{stringliteral}{"  in fractional seconds. Default is 1/1000.\(\backslash\)n"});
749   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded encoders:\(\backslash\)n\(\backslash\)n"});
750 
751   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
752   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_encoder; ++i) \{
753     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} encoder = get\_aom\_encoder\_by\_index(i);
754     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *defstr = (i == (num\_encoder - 1)) ? \textcolor{stringliteral}{"(default)"} : \textcolor{stringliteral}{""};
755     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s %s\(\backslash\)n"}, encoder->name,
756             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()), defstr);
757   \}
758   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)n        "});
759   fprintf(fout, \textcolor{stringliteral}{"Use --codec to switch to a non-default encoder.\(\backslash\)n\(\backslash\)n"});
760 \}
761 
762 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
763   show\_help(stderr, 1);
764   exit(EXIT\_FAILURE);
765 \}
766 
767 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
768 \textcolor{preprocessor}{#define ARG\_CTRL\_CNT\_MAX NELEMENTS(av1\_arg\_ctrl\_map)}
769 \textcolor{preprocessor}{#endif}
770 
771 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
772 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} stereo\_format\_t;
773 \textcolor{keyword}{struct }WebmOutputContext \{
774   \textcolor{keywordtype}{int} debug;
775 \};
776 \textcolor{preprocessor}{#endif}
777 
778 \textcolor{comment}{/* Per-stream configuration */}
779 \textcolor{keyword}{struct }stream\_config \{
780   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} cfg;
781   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *out\_fn;
782   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *stats\_fn;
783 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
784   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fpmb\_stats\_fn;
785 \textcolor{preprocessor}{#endif}
786   stereo\_format\_t stereo\_fmt;
787   \textcolor{keywordtype}{int} arg\_ctrls[ARG\_CTRL\_CNT\_MAX][2];
788   \textcolor{keywordtype}{int} arg\_ctrl\_cnt;
789   \textcolor{keywordtype}{int} write\_webm;
790   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *film\_grain\_filename;
791   \textcolor{keywordtype}{int} write\_ivf;
792   \textcolor{comment}{// whether to use 16bit internal buffers}
793   \textcolor{keywordtype}{int} use\_16bit\_internal;
794 \};
795 
796 \textcolor{keyword}{struct }stream\_state \{
797   \textcolor{keywordtype}{int} index;
798   \textcolor{keyword}{struct }stream\_state *next;
799   \textcolor{keyword}{struct }stream\_config config;
800   FILE *file;
801   \textcolor{keyword}{struct }rate\_hist *rate\_hist;
802   \textcolor{keyword}{struct }WebmOutputContext webm\_ctx;
803   uint64\_t psnr\_sse\_total;
804   uint64\_t psnr\_samples\_total;
805   \textcolor{keywordtype}{double} psnr\_totals[4];
806   \textcolor{keywordtype}{int} psnr\_count;
807   \textcolor{keywordtype}{int} counts[64];
808   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} encoder;
809   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_out;
810   uint64\_t cx\_time;
811   \textcolor{keywordtype}{size\_t} nbytes;
812   stats\_io\_t stats;
813 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
814   stats\_io\_t fpmb\_stats;
815 \textcolor{preprocessor}{#endif}
816   \textcolor{keyword}{struct }\hyperlink{structaom__image}{aom\_image} *img;
817   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
818   \textcolor{keywordtype}{int} mismatch\_seen;
819 \};
820 
821 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_positive\_rational(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg,
822                                        \textcolor{keyword}{struct} \hyperlink{structaom__rational}{aom\_rational} *rat) \{
823   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} < 0) \{
824     rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} *= -1;
825     rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} *= -1;
826   \}
827 
828   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} < 0) die(\textcolor{stringliteral}{"Error: %s must be positive\(\backslash\)n"}, msg);
829 
830   \textcolor{keywordflow}{if} (!rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den}) die(\textcolor{stringliteral}{"Error: %s has zero denominator\(\backslash\)n"}, msg);
831 \}
832 
833 \textcolor{keyword}{static} \textcolor{keywordtype}{void} parse\_global\_config(\textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} *argc,
834                                 \textcolor{keywordtype}{char} ***argv) \{
835   \textcolor{keywordtype}{char} **argi, **argj;
836   \textcolor{keyword}{struct }arg arg;
837   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
838   \textcolor{keywordtype}{char} **argv\_local = (\textcolor{keywordtype}{char} **)*argv;
839 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
840   \textcolor{keywordtype}{int} argc\_local = *argc;
841 \textcolor{preprocessor}{#endif}
842   \textcolor{keywordflow}{if} (num\_encoder < 1) die(\textcolor{stringliteral}{"Error: no valid encoder available\(\backslash\)n"});
843 
844   \textcolor{comment}{/* Initialize default parameters */}
845   memset(global, 0, \textcolor{keyword}{sizeof}(*global));
846   global->codec = get\_aom\_encoder\_by\_index(num\_encoder - 1);
847   global->passes = 0;
848   global->color\_type = I420;
849 
850 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
851   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cfg = NULL;
852   \textcolor{keywordtype}{int} cfg\_included = 0;
853 \textcolor{preprocessor}{#endif}
854   \textcolor{keywordflow}{for} (argi = argj = argv\_local; (*argj = *argi); argi += arg.argv\_step) \{
855     arg.argv\_step = 1;
856 
857 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
858     \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_cfg, argi)) \{
859       \textcolor{keywordflow}{if} (cfg\_included) \textcolor{keywordflow}{continue};
860       cfg = arg.val;
861 
862       arg\_cfg(&argc\_local, &argv\_local, cfg);
863 
864       *argj = *argi = *argv\_local;
865       argj = argi = argv\_local;
866       *argv = argv\_local;
867       cfg\_included = 1;
868       \textcolor{keywordflow}{continue};
869     \}
870 \textcolor{preprocessor}{#endif}
871     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
872       show\_help(stdout, 0);
873       exit(EXIT\_SUCCESS);
874     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
875       global->codec = get\_aom\_encoder\_by\_name(arg.val);
876       \textcolor{keywordflow}{if} (!global->codec)
877         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
878     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &passes, argi)) \{
879       global->passes = arg\_parse\_uint(&arg);
880 
881       \textcolor{keywordflow}{if} (global->passes < 1 || global->passes > 2)
882         die(\textcolor{stringliteral}{"Error: Invalid number of passes (%d)\(\backslash\)n"}, global->passes);
883     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pass\_arg, argi)) \{
884       global->pass = arg\_parse\_uint(&arg);
885 
886       \textcolor{keywordflow}{if} (global->pass < 1 || global->pass > 2)
887         die(\textcolor{stringliteral}{"Error: Invalid pass selected (%d)\(\backslash\)n"}, global->pass);
888     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &usage, argi))
889       global->usage = arg\_parse\_uint(&arg);
890     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &good\_dl, argi))
891       warn(\textcolor{stringliteral}{"Deprecated --good option! Ignoring\(\backslash\)n"});
892     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi))
893       global->color\_type = YV12;
894     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi))
895       global->color\_type = I420;
896     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i422, argi))
897       global->color\_type = I422;
898     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i444, argi))
899       global->color\_type = I444;
900     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &quietarg, argi))
901       global->quiet = 1;
902     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi))
903       global->verbose = 1;
904     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limit, argi))
905       global->limit = arg\_parse\_uint(&arg);
906     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skip, argi))
907       global->skip\_frames = arg\_parse\_uint(&arg);
908     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &psnrarg, argi))
909       global->show\_psnr = 1;
910     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &recontest, argi))
911       global->test\_decode = arg\_parse\_enum\_or\_int(&arg);
912     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framerate, argi)) \{
913       global->framerate = arg\_parse\_rational(&arg);
914       validate\_positive\_rational(arg.name, &global->framerate);
915       global->have\_framerate = 1;
916     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &out\_part, argi))
917       global->out\_part = 1;
918     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &debugmode, argi))
919       global->debug = 1;
920     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &q\_hist\_n, argi))
921       global->show\_q\_hist\_buckets = arg\_parse\_uint(&arg);
922     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rate\_hist\_n, argi))
923       global->show\_rate\_hist\_buckets = arg\_parse\_uint(&arg);
924     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warnings, argi))
925       global->disable\_warnings = 1;
926     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warning\_prompt, argi))
927       global->disable\_warning\_prompt = 1;
928     \textcolor{keywordflow}{else}
929       argj++;
930   \}
931 
932   \textcolor{keywordflow}{if} (global->pass) \{
933     \textcolor{comment}{/* DWIM: Assume the user meant passes=2 if pass=2 is specified */}
934     \textcolor{keywordflow}{if} (global->pass > global->passes) \{
935       warn(\textcolor{stringliteral}{"Assuming --pass=%d implies --passes=%d\(\backslash\)n"}, global->pass,
936            global->pass);
937       global->passes = global->pass;
938     \}
939   \}
940   \textcolor{comment}{/* Validate global config */}
941   \textcolor{keywordflow}{if} (global->passes == 0) \{
942 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
943     \textcolor{comment}{// Make default AV1 passes = 2 until there is a better quality 1-pass}
944     \textcolor{comment}{// encoder}
945     \textcolor{keywordflow}{if} (global->codec != NULL && global->codec->name != NULL)
946       global->passes = (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) ? 2 : 1;
947 \textcolor{preprocessor}{#else}
948     global->passes = 1;
949 \textcolor{preprocessor}{#endif}
950   \}
951 \}
952 
953 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input) \{
954   \textcolor{comment}{/* Parse certain options from the input file, if possible */}
955   input->file = strcmp(input->filename, \textcolor{stringliteral}{"-"}) ? fopen(input->filename, \textcolor{stringliteral}{"rb"})
956                                              : set\_binary\_mode(stdin);
957 
958   \textcolor{keywordflow}{if} (!input->file) fatal(\textcolor{stringliteral}{"Failed to open input file"});
959 
960   \textcolor{keywordflow}{if} (!fseeko(input->file, 0, SEEK\_END)) \{
961     \textcolor{comment}{/* Input file is seekable. Figure out how long it is, so we can get}
962 \textcolor{comment}{     * progress info.}
963 \textcolor{comment}{     */}
964     input->length = ftello(input->file);
965     rewind(input->file);
966   \}
967 
968   \textcolor{comment}{/* Default to 1:1 pixel aspect ratio. */}
969   input->pixel\_aspect\_ratio.numerator = 1;
970   input->pixel\_aspect\_ratio.denominator = 1;
971 
972   \textcolor{comment}{/* For RAW input sources, these bytes will applied on the first frame}
973 \textcolor{comment}{   *  in read\_frame().}
974 \textcolor{comment}{   */}
975   input->detect.buf\_read = fread(input->detect.buf, 1, 4, input->file);
976   input->detect.position = 0;
977 
978   \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && file\_is\_y4m(input->detect.buf)) \{
979     \textcolor{keywordflow}{if} (y4m\_input\_open(&input->y4m, input->file, input->detect.buf, 4,
980                        input->only\_i420) >= 0) \{
981       input->file\_type = FILE\_TYPE\_Y4M;
982       input->width = input->y4m.pic\_w;
983       input->height = input->y4m.pic\_h;
984       input->pixel\_aspect\_ratio.numerator = input->y4m.par\_n;
985       input->pixel\_aspect\_ratio.denominator = input->y4m.par\_d;
986       input->framerate.numerator = input->y4m.fps\_n;
987       input->framerate.denominator = input->y4m.fps\_d;
988       input->fmt = input->y4m.aom\_fmt;
989       input->bit\_depth = input->y4m.bit\_depth;
990     \} \textcolor{keywordflow}{else}
991       fatal(\textcolor{stringliteral}{"Unsupported Y4M stream."});
992   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && fourcc\_is\_ivf(input->detect.buf)) \{
993     fatal(\textcolor{stringliteral}{"IVF is not supported as input."});
994   \} \textcolor{keywordflow}{else} \{
995     input->file\_type = FILE\_TYPE\_RAW;
996   \}
997 \}
998 
999 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input) \{
1000   fclose(input->file);
1001   \textcolor{keywordflow}{if} (input->file\_type == FILE\_TYPE\_Y4M) y4m\_input\_close(&input->y4m);
1002 \}
1003 
1004 \textcolor{keyword}{static} \textcolor{keyword}{struct }stream\_state *new\_stream(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1005                                        \textcolor{keyword}{struct} stream\_state *prev) \{
1006   \textcolor{keyword}{struct }stream\_state *stream;
1007 
1008   stream = calloc(1, \textcolor{keyword}{sizeof}(*stream));
1009   \textcolor{keywordflow}{if} (stream == NULL) \{
1010     fatal(\textcolor{stringliteral}{"Failed to allocate new stream."});
1011   \}
1012 
1013   \textcolor{keywordflow}{if} (prev) \{
1014     memcpy(stream, prev, \textcolor{keyword}{sizeof}(*stream));
1015     stream->index++;
1016     prev->next = stream;
1017   \} \textcolor{keywordflow}{else} \{
1018     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
1019 
1020     \textcolor{comment}{/* Populate encoder configuration */}
1021     res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(global->codec->codec\_interface(),
1022                                        &stream->config.cfg, global->usage);
1023     \textcolor{keywordflow}{if} (res) fatal(\textcolor{stringliteral}{"Failed to get config: %s\(\backslash\)n"}, \hyperlink{group__codec_ga83c6525528574d1a88e73a9f605c9115}{aom\_codec\_err\_to\_string}(res));
1024 
1025     \textcolor{comment}{/* Change the default timebase to a high enough value so that the}
1026 \textcolor{comment}{     * encoder will always create strictly increasing timestamps.}
1027 \textcolor{comment}{     */}
1028     stream->config.cfg.g\_timebase.den = 1000;
1029 
1030     \textcolor{comment}{/* Never use the library's default resolution, require it be parsed}
1031 \textcolor{comment}{     * from the file or set on the command line.}
1032 \textcolor{comment}{     */}
1033     stream->config.cfg.g\_w = 0;
1034     stream->config.cfg.g\_h = 0;
1035 
1036     \textcolor{comment}{/* Initialize remaining stream parameters */}
1037     stream->config.write\_webm = 1;
1038     stream->config.write\_ivf = 0;
1039 
1040 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1041     stream->config.stereo\_fmt = STEREO\_FORMAT\_MONO;
1042     stream->webm\_ctx.last\_pts\_ns = -1;
1043     stream->webm\_ctx.writer = NULL;
1044     stream->webm\_ctx.segment = NULL;
1045 \textcolor{preprocessor}{#endif}
1046 
1047     \textcolor{comment}{/* Allows removal of the application version from the EBML tags */}
1048     stream->webm\_ctx.debug = global->debug;
1049   \}
1050 
1051   \textcolor{comment}{/* Output files must be specified for each stream */}
1052   stream->config.out\_fn = NULL;
1053 
1054   stream->next = NULL;
1055   \textcolor{keywordflow}{return} stream;
1056 \}
1057 
1058 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_config\_arg\_ctrls(\textcolor{keyword}{struct} stream\_config *config, \textcolor{keywordtype}{int} key,
1059                                  \textcolor{keyword}{const} \textcolor{keyword}{struct} arg *arg) \{
1060   \textcolor{keywordtype}{int} j;
1061   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE}) \{
1062     config->film\_grain\_filename = arg->val;
1063     \textcolor{keywordflow}{return};
1064   \}
1065 
1066   \textcolor{comment}{/* Point either to the next free element or the first instance of this}
1067 \textcolor{comment}{   * control.}
1068 \textcolor{comment}{   */}
1069   \textcolor{keywordflow}{for} (j = 0; j < config->arg\_ctrl\_cnt; j++)
1070     \textcolor{keywordflow}{if} (config->arg\_ctrls[j][0] == key) \textcolor{keywordflow}{break};
1071 
1072   \textcolor{comment}{/* Update/insert */}
1073   assert(j < (\textcolor{keywordtype}{int})ARG\_CTRL\_CNT\_MAX);
1074   config->arg\_ctrls[j][0] = key;
1075   config->arg\_ctrls[j][1] = arg\_parse\_enum\_or\_int(arg);
1076   \textcolor{keywordflow}{if} (j == config->arg\_ctrl\_cnt) config->arg\_ctrl\_cnt++;
1077 \}
1078 
1079 \textcolor{keyword}{static} \textcolor{keywordtype}{int} parse\_stream\_params(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1080                                \textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{char} **argv) \{
1081   \textcolor{keywordtype}{char} **argi, **argj;
1082   \textcolor{keyword}{struct }arg arg;
1083   \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t **ctrl\_args = no\_args;
1084   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} *ctrl\_args\_map = NULL;
1085   \textcolor{keyword}{struct }stream\_config *config = &stream->config;
1086   \textcolor{keywordtype}{int} eos\_mark\_found = 0;
1087   \textcolor{keywordtype}{int} webm\_forced = 0;
1088 
1089   \textcolor{comment}{// Handle codec specific options}
1090   \textcolor{keywordflow}{if} (0) \{
1091 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1092   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1093     \textcolor{comment}{// TODO(jingning): Reuse AV1 specific encoder configuration parameters.}
1094     \textcolor{comment}{// Consider to expand this set for AV1 encoder control.}
1095     ctrl\_args = av1\_args;
1096     ctrl\_args\_map = av1\_arg\_ctrl\_map;
1097 \textcolor{preprocessor}{#endif}
1098   \}
1099 
1100   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1101     arg.argv\_step = 1;
1102 
1103     \textcolor{comment}{/* Once we've found an end-of-stream marker (--) we want to continue}
1104 \textcolor{comment}{     * shifting arguments but not consuming them.}
1105 \textcolor{comment}{     */}
1106     \textcolor{keywordflow}{if} (eos\_mark\_found) \{
1107       argj++;
1108       \textcolor{keywordflow}{continue};
1109     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(*argj, \textcolor{stringliteral}{"--"})) \{
1110       eos\_mark\_found = 1;
1111       \textcolor{keywordflow}{continue};
1112     \}
1113 
1114     \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
1115       config->out\_fn = arg.val;
1116       \textcolor{keywordflow}{if} (!webm\_forced) \{
1117         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} out\_fn\_len = strlen(config->out\_fn);
1118         \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1119             !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".ivf"})) \{
1120           config->write\_webm = 0;
1121           config->write\_ivf = 1;
1122         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1123                    !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".obu"})) \{
1124           config->write\_webm = 0;
1125           config->write\_ivf = 0;
1126         \}
1127       \}
1128     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fpf\_name, argi)) \{
1129       config->stats\_fn = arg.val;
1130 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1131     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fpmbf\_name, argi)) \{
1132       config->fpmb\_stats\_fn = arg.val;
1133 \textcolor{preprocessor}{#endif}
1134     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_webm, argi)) \{
1135 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1136       config->write\_webm = 1;
1137       webm\_forced = 1;
1138 \textcolor{preprocessor}{#else}
1139       die(\textcolor{stringliteral}{"Error: --webm specified but webm is disabled."});
1140 \textcolor{preprocessor}{#endif}
1141     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_ivf, argi)) \{
1142       config->write\_webm = 0;
1143       config->write\_ivf = 1;
1144     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_obu, argi)) \{
1145       config->write\_webm = 0;
1146       config->write\_ivf = 0;
1147     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threads, argi)) \{
1148       config->cfg.g\_threads = arg\_parse\_uint(&arg);
1149     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &profile, argi)) \{
1150       config->cfg.g\_profile = arg\_parse\_uint(&arg);
1151     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &width, argi)) \{
1152       config->cfg.g\_w = arg\_parse\_uint(&arg);
1153     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &height, argi)) \{
1154       config->cfg.g\_h = arg\_parse\_uint(&arg);
1155     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_width, argi)) \{
1156       config->cfg.g\_forced\_max\_frame\_width = arg\_parse\_uint(&arg);
1157     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_height, argi)) \{
1158       config->cfg.g\_forced\_max\_frame\_height = arg\_parse\_uint(&arg);
1159     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bitdeptharg, argi)) \{
1160       config->cfg.g\_bit\_depth = arg\_parse\_enum\_or\_int(&arg);
1161     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &inbitdeptharg, argi)) \{
1162       config->cfg.g\_input\_bit\_depth = arg\_parse\_uint(&arg);
1163 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1164     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &stereo\_mode, argi)) \{
1165       config->stereo\_fmt = arg\_parse\_enum\_or\_int(&arg);
1166 \textcolor{preprocessor}{#endif}
1167     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &timebase, argi)) \{
1168       config->cfg.g\_timebase = arg\_parse\_rational(&arg);
1169       validate\_positive\_rational(arg.name, &config->cfg.g\_timebase);
1170     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &global\_error\_resilient, argi)) \{
1171       config->cfg.g\_error\_resilient = arg\_parse\_uint(&arg);
1172     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &lag\_in\_frames, argi)) \{
1173       config->cfg.g\_lag\_in\_frames = arg\_parse\_uint(&arg);
1174     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &large\_scale\_tile, argi)) \{
1175       config->cfg.large\_scale\_tile = arg\_parse\_uint(&arg);
1176     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &monochrome, argi)) \{
1177       config->cfg.monochrome = 1;
1178     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &full\_still\_picture\_hdr, argi)) \{
1179       config->cfg.full\_still\_picture\_hdr = 1;
1180     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &dropframe\_thresh, argi)) \{
1181       config->cfg.rc\_dropframe\_thresh = arg\_parse\_uint(&arg);
1182     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_mode, argi)) \{
1183       config->cfg.rc\_resize\_mode = arg\_parse\_uint(&arg);
1184     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_denominator, argi)) \{
1185       config->cfg.rc\_resize\_denominator = arg\_parse\_uint(&arg);
1186     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_kf\_denominator, argi)) \{
1187       config->cfg.rc\_resize\_kf\_denominator = arg\_parse\_uint(&arg);
1188     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_mode, argi)) \{
1189       config->cfg.rc\_superres\_mode = arg\_parse\_uint(&arg);
1190     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_denominator, argi)) \{
1191       config->cfg.rc\_superres\_denominator = arg\_parse\_uint(&arg);
1192     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_denominator, argi)) \{
1193       config->cfg.rc\_superres\_kf\_denominator = arg\_parse\_uint(&arg);
1194     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_qthresh, argi)) \{
1195       config->cfg.rc\_superres\_qthresh = arg\_parse\_uint(&arg);
1196     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_qthresh, argi)) \{
1197       config->cfg.rc\_superres\_kf\_qthresh = arg\_parse\_uint(&arg);
1198     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &end\_usage, argi)) \{
1199       config->cfg.rc\_end\_usage = arg\_parse\_enum\_or\_int(&arg);
1200     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &target\_bitrate, argi)) \{
1201       config->cfg.rc\_target\_bitrate = arg\_parse\_uint(&arg);
1202     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &min\_quantizer, argi)) \{
1203       config->cfg.rc\_min\_quantizer = arg\_parse\_uint(&arg);
1204     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &max\_quantizer, argi)) \{
1205       config->cfg.rc\_max\_quantizer = arg\_parse\_uint(&arg);
1206     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &undershoot\_pct, argi)) \{
1207       config->cfg.rc\_undershoot\_pct = arg\_parse\_uint(&arg);
1208     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &overshoot\_pct, argi)) \{
1209       config->cfg.rc\_overshoot\_pct = arg\_parse\_uint(&arg);
1210     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_sz, argi)) \{
1211       config->cfg.rc\_buf\_sz = arg\_parse\_uint(&arg);
1212     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_initial\_sz, argi)) \{
1213       config->cfg.rc\_buf\_initial\_sz = arg\_parse\_uint(&arg);
1214     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_optimal\_sz, argi)) \{
1215       config->cfg.rc\_buf\_optimal\_sz = arg\_parse\_uint(&arg);
1216     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bias\_pct, argi)) \{
1217       config->cfg.rc\_2pass\_vbr\_bias\_pct = arg\_parse\_uint(&arg);
1218       \textcolor{keywordflow}{if} (global->passes < 2)
1219         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1220     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &minsection\_pct, argi)) \{
1221       config->cfg.rc\_2pass\_vbr\_minsection\_pct = arg\_parse\_uint(&arg);
1222 
1223       \textcolor{keywordflow}{if} (global->passes < 2)
1224         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1225     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &maxsection\_pct, argi)) \{
1226       config->cfg.rc\_2pass\_vbr\_maxsection\_pct = arg\_parse\_uint(&arg);
1227 
1228       \textcolor{keywordflow}{if} (global->passes < 2)
1229         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1230     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fwd\_kf\_enabled, argi)) \{
1231       config->cfg.fwd\_kf\_enabled = arg\_parse\_uint(&arg);
1232     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_min\_dist, argi)) \{
1233       config->cfg.kf\_min\_dist = arg\_parse\_uint(&arg);
1234     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_max\_dist, argi)) \{
1235       config->cfg.kf\_max\_dist = arg\_parse\_uint(&arg);
1236     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_disabled, argi)) \{
1237       config->cfg.kf\_mode = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
1238     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_dist, argi)) \{
1239       config->cfg.sframe\_dist = arg\_parse\_uint(&arg);
1240     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_mode, argi)) \{
1241       config->cfg.sframe\_mode = arg\_parse\_uint(&arg);
1242     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &save\_as\_annexb, argi)) \{
1243       config->cfg.save\_as\_annexb = arg\_parse\_uint(&arg);
1244     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_width, argi)) \{
1245       config->cfg.tile\_width\_count =
1246           arg\_parse\_list(&arg, config->cfg.tile\_widths, \hyperlink{aom__encoder_8h_a3ec4904ea175471a03d10705f384d07c}{MAX\_TILE\_WIDTHS});
1247     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_height, argi)) \{
1248       config->cfg.tile\_height\_count =
1249           arg\_parse\_list(&arg, config->cfg.tile\_heights, \hyperlink{aom__encoder_8h_a446aae868ff07f3971d9e84b6602a890}{MAX\_TILE\_HEIGHTS});
1250 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1251     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &ext\_partition, argi)) \{
1252       config->cfg.cfg.ext\_partition = !!arg\_parse\_uint(&arg) > 0;
1253 \textcolor{preprocessor}{#endif}
1254     \} \textcolor{keywordflow}{else} \{
1255       \textcolor{keywordtype}{int} i, match = 0;
1256       \textcolor{keywordflow}{for} (i = 0; ctrl\_args[i]; i++) \{
1257         \textcolor{keywordflow}{if} (arg\_match(&arg, ctrl\_args[i], argi)) \{
1258           match = 1;
1259           \textcolor{keywordflow}{if} (ctrl\_args\_map) \{
1260             set\_config\_arg\_ctrls(config, ctrl\_args\_map[i], &arg);
1261           \}
1262         \}
1263       \}
1264       \textcolor{keywordflow}{if} (!match) argj++;
1265     \}
1266   \}
1267   config->use\_16bit\_internal =
1268       config->cfg.g\_bit\_depth > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH;
1269   \textcolor{keywordflow}{return} eos\_mark\_found;
1270 \}
1271 
1272 \textcolor{preprocessor}{#define FOREACH\_STREAM(iterator, list)                 \(\backslash\)}
1273 \textcolor{preprocessor}{  for (struct stream\_state *iterator = list; iterator; \(\backslash\)}
1274 \textcolor{preprocessor}{       iterator = iterator->next)}
1275 
1276 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_stream\_config(\textcolor{keyword}{const} \textcolor{keyword}{struct} stream\_state *stream,
1277                                    \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1278   \textcolor{keyword}{const} \textcolor{keyword}{struct }stream\_state *streami;
1279   (void)global;
1280 
1281   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w || !stream->config.cfg.g\_h)
1282     fatal(
1283         \textcolor{stringliteral}{"Stream %d: Specify stream dimensions with --width (-w) "}
1284         \textcolor{stringliteral}{" and --height (-h)"},
1285         stream->index);
1286 
1287   \textcolor{comment}{// Check that the codec bit depth is greater than the input bit depth.}
1288   \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth >
1289       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth) \{
1290     fatal(\textcolor{stringliteral}{"Stream %d: codec bit depth (%d) less than input bit depth (%d)"},
1291           stream->index, (\textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth,
1292           stream->config.cfg.g\_input\_bit\_depth);
1293   \}
1294 
1295   \textcolor{keywordflow}{for} (streami = stream; streami; streami = streami->next) \{
1296     \textcolor{comment}{/* All streams require output files */}
1297     \textcolor{keywordflow}{if} (!streami->config.out\_fn)
1298       fatal(\textcolor{stringliteral}{"Stream %d: Output file is required (specify with -o)"},
1299             streami->index);
1300 
1301     \textcolor{comment}{/* Check for two streams outputting to the same file */}
1302     \textcolor{keywordflow}{if} (streami != stream) \{
1303       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.out\_fn;
1304       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.out\_fn;
1305       \textcolor{keywordflow}{if} (!strcmp(a, b) && strcmp(a, \textcolor{stringliteral}{"/dev/null"}) && strcmp(a, \textcolor{stringliteral}{":nul"}))
1306         fatal(\textcolor{stringliteral}{"Stream %d: duplicate output file (from stream %d)"},
1307               streami->index, stream->index);
1308     \}
1309 
1310     \textcolor{comment}{/* Check for two streams sharing a stats file. */}
1311     \textcolor{keywordflow}{if} (streami != stream) \{
1312       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.stats\_fn;
1313       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.stats\_fn;
1314       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1315         fatal(\textcolor{stringliteral}{"Stream %d: duplicate stats file (from stream %d)"},
1316               streami->index, stream->index);
1317     \}
1318 
1319 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1320     \textcolor{comment}{/* Check for two streams sharing a mb stats file. */}
1321     \textcolor{keywordflow}{if} (streami != stream) \{
1322       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.fpmb\_stats\_fn;
1323       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.fpmb\_stats\_fn;
1324       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1325         fatal(\textcolor{stringliteral}{"Stream %d: duplicate mb stats file (from stream %d)"},
1326               streami->index, stream->index);
1327     \}
1328 \textcolor{preprocessor}{#endif}
1329   \}
1330 \}
1331 
1332 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_stream\_dimensions(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w,
1333                                   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h) \{
1334   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w) \{
1335     \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h)
1336       stream->config.cfg.g\_w = w;
1337     \textcolor{keywordflow}{else}
1338       stream->config.cfg.g\_w = w * stream->config.cfg.g\_h / h;
1339   \}
1340   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h) \{
1341     stream->config.cfg.g\_h = h * stream->config.cfg.g\_w / w;
1342   \}
1343 \}
1344 
1345 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_type\_to\_string(\textcolor{keyword}{enum} VideoFileType t) \{
1346   \textcolor{keywordflow}{switch} (t) \{
1347     \textcolor{keywordflow}{case} FILE\_TYPE\_RAW: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"RAW"};
1348     \textcolor{keywordflow}{case} FILE\_TYPE\_Y4M: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Y4M"};
1349     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1350   \}
1351 \}
1352 
1353 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *image\_format\_to\_string(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} f) \{
1354   \textcolor{keywordflow}{switch} (f) \{
1355     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I420"};
1356     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I422"};
1357     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I444"};
1358     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"YV12"};
1359     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42016"};
1360     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42216"};
1361     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I44416"};
1362     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1363   \}
1364 \}
1365 
1366 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_stream\_config(\textcolor{keyword}{struct} stream\_state *stream,
1367                                \textcolor{keyword}{struct} AvxEncoderConfig *global,
1368                                \textcolor{keyword}{struct} AvxInputContext *input) \{
1369 \textcolor{preprocessor}{#define SHOW(field) \(\backslash\)}
1370 \textcolor{preprocessor}{  fprintf(stderr, "    %-28s = %d\(\backslash\)n", #field, stream->config.cfg.field)}
1371 
1372   \textcolor{keywordflow}{if} (stream->index == 0) \{
1373     fprintf(stderr, \textcolor{stringliteral}{"Codec: %s\(\backslash\)n"},
1374             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(global->codec->codec\_interface()));
1375     fprintf(stderr, \textcolor{stringliteral}{"Source file: %s File Type: %s Format: %s\(\backslash\)n"},
1376             input->filename, file\_type\_to\_string(input->file\_type),
1377             image\_format\_to\_string(input->fmt));
1378   \}
1379   \textcolor{keywordflow}{if} (stream->next || stream->index)
1380     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nStream Index: %d\(\backslash\)n"}, stream->index);
1381   fprintf(stderr, \textcolor{stringliteral}{"Destination file: %s\(\backslash\)n"}, stream->config.out\_fn);
1382   fprintf(stderr, \textcolor{stringliteral}{"Coding path: %s\(\backslash\)n"},
1383           stream->config.use\_16bit\_internal ? \textcolor{stringliteral}{"HBD"} : \textcolor{stringliteral}{"LBD"});
1384   fprintf(stderr, \textcolor{stringliteral}{"Encoder parameters:\(\backslash\)n"});
1385 
1386   SHOW(g\_usage);
1387   SHOW(g\_threads);
1388   SHOW(g\_profile);
1389   SHOW(g\_w);
1390   SHOW(g\_h);
1391   SHOW(g\_bit\_depth);
1392   SHOW(g\_input\_bit\_depth);
1393   SHOW(g\_timebase.num);
1394   SHOW(g\_timebase.den);
1395   SHOW(g\_error\_resilient);
1396   SHOW(g\_pass);
1397   SHOW(g\_lag\_in\_frames);
1398   SHOW(large\_scale\_tile);
1399   SHOW(rc\_dropframe\_thresh);
1400   SHOW(rc\_resize\_mode);
1401   SHOW(rc\_resize\_denominator);
1402   SHOW(rc\_resize\_kf\_denominator);
1403   SHOW(rc\_superres\_mode);
1404   SHOW(rc\_superres\_denominator);
1405   SHOW(rc\_superres\_kf\_denominator);
1406   SHOW(rc\_superres\_qthresh);
1407   SHOW(rc\_superres\_kf\_qthresh);
1408   SHOW(rc\_end\_usage);
1409   SHOW(rc\_target\_bitrate);
1410   SHOW(rc\_min\_quantizer);
1411   SHOW(rc\_max\_quantizer);
1412   SHOW(rc\_undershoot\_pct);
1413   SHOW(rc\_overshoot\_pct);
1414   SHOW(rc\_buf\_sz);
1415   SHOW(rc\_buf\_initial\_sz);
1416   SHOW(rc\_buf\_optimal\_sz);
1417   SHOW(rc\_2pass\_vbr\_bias\_pct);
1418   SHOW(rc\_2pass\_vbr\_minsection\_pct);
1419   SHOW(rc\_2pass\_vbr\_maxsection\_pct);
1420   SHOW(fwd\_kf\_enabled);
1421   SHOW(kf\_mode);
1422   SHOW(kf\_min\_dist);
1423   SHOW(kf\_max\_dist);
1424 \}
1425 
1426 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1427                              \textcolor{keyword}{struct} AvxEncoderConfig *global,
1428                              \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxRational *pixel\_aspect\_ratio) \{
1429   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fn = stream->config.out\_fn;
1430   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1431 
1432   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1433 
1434   stream->file = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"wb"}) : set\_binary\_mode(stdout);
1435 
1436   \textcolor{keywordflow}{if} (!stream->file) fatal(\textcolor{stringliteral}{"Failed to open output file"});
1437 
1438   \textcolor{keywordflow}{if} (stream->config.write\_webm && fseek(stream->file, 0, SEEK\_CUR))
1439     fatal(\textcolor{stringliteral}{"WebM output to pipes not supported."});
1440 
1441 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1442   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1443     stream->webm\_ctx.stream = stream->file;
1444     write\_webm\_file\_header(&stream->webm\_ctx, cfg, stream->config.stereo\_fmt,
1445                            global->codec->fourcc, pixel\_aspect\_ratio);
1446   \}
1447 \textcolor{preprocessor}{#else}
1448   (void)pixel\_aspect\_ratio;
1449 \textcolor{preprocessor}{#endif}
1450 
1451   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1452     ivf\_write\_file\_header(stream->file, cfg, global->codec->fourcc, 0);
1453   \}
1454 \}
1455 
1456 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1457                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fourcc) \{
1458   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1459 
1460   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1461 
1462 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1463   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1464     write\_webm\_file\_footer(&stream->webm\_ctx);
1465   \}
1466 \textcolor{preprocessor}{#endif}
1467 
1468   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1469     \textcolor{keywordflow}{if} (!fseek(stream->file, 0, SEEK\_SET))
1470       ivf\_write\_file\_header(stream->file, &stream->config.cfg, fourcc,
1471                             stream->frames\_out);
1472   \}
1473 
1474   fclose(stream->file);
1475 \}
1476 
1477 \textcolor{keyword}{static} \textcolor{keywordtype}{void} setup\_pass(\textcolor{keyword}{struct} stream\_state *stream,
1478                        \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} pass) \{
1479   \textcolor{keywordflow}{if} (stream->config.stats\_fn) \{
1480     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->stats, stream->config.stats\_fn, pass))
1481       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1482   \} \textcolor{keywordflow}{else} \{
1483     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->stats, pass))
1484       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1485   \}
1486 
1487 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1488   \textcolor{keywordflow}{if} (stream->config.fpmb\_stats\_fn) \{
1489     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->fpmb\_stats, stream->config.fpmb\_stats\_fn,
1490                          pass))
1491       fatal(\textcolor{stringliteral}{"Failed to open mb statistics store"});
1492   \} \textcolor{keywordflow}{else} \{
1493     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->fpmb\_stats, pass))
1494       fatal(\textcolor{stringliteral}{"Failed to open mb statistics store"});
1495   \}
1496 \textcolor{preprocessor}{#endif}
1497 
1498   stream->config.cfg.g\_pass = global->passes == 2
1499                                   ? pass ? \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS} : 
      \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}
1500                                   : \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a1b4b8ee9c1910fc59ac9dfd9700f3f02}{AOM\_RC\_ONE\_PASS};
1501   \textcolor{keywordflow}{if} (pass) \{
1502     stream->config.cfg.rc\_twopass\_stats\_in = stats\_get(&stream->stats);
1503 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1504     stream->config.cfg.rc\_firstpass\_mb\_stats\_in =
1505         stats\_get(&stream->fpmb\_stats);
1506 \textcolor{preprocessor}{#endif}
1507   \}
1508 
1509   stream->cx\_time = 0;
1510   stream->nbytes = 0;
1511   stream->frames\_out = 0;
1512 \}
1513 
1514 \textcolor{keyword}{static} \textcolor{keywordtype}{void} initialize\_encoder(\textcolor{keyword}{struct} stream\_state *stream,
1515                                \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1516   \textcolor{keywordtype}{int} i;
1517   \textcolor{keywordtype}{int} flags = 0;
1518 
1519   flags |= global->show\_psnr ? \hyperlink{group__encoder_gae722c9f9ba9b4ca8dba6bbe7c0692024}{AOM\_CODEC\_USE\_PSNR} : 0;
1520   flags |= global->out\_part ? \hyperlink{group__encoder_gadb4a188ee79fd79fc5f2f1ae8df69826}{AOM\_CODEC\_USE\_OUTPUT\_PARTITION} : 0;
1521   flags |= stream->config.use\_16bit\_internal ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH} : 0;
1522 
1523   \textcolor{comment}{/* Construct Encoder Context */}
1524   \hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&stream->encoder, global->codec->codec\_interface(),
1525                      &stream->config.cfg, flags);
1526   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to initialize encoder"});
1527 
1528   \textcolor{comment}{/* Note that we bypass the aom\_codec\_control wrapper macro because}
1529 \textcolor{comment}{   * we're being clever to store the control IDs in an array. Real}
1530 \textcolor{comment}{   * applications will want to make use of the enumerations directly}
1531 \textcolor{comment}{   */}
1532   \textcolor{keywordflow}{for} (i = 0; i < stream->config.arg\_ctrl\_cnt; i++) \{
1533     \textcolor{keywordtype}{int} ctrl = stream->config.arg\_ctrls[i][0];
1534     \textcolor{keywordtype}{int} value = stream->config.arg\_ctrls[i][1];
1535     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, ctrl, value))
1536       fprintf(stderr, \textcolor{stringliteral}{"Error: Tried to set control %d = %d\(\backslash\)n"}, ctrl, value);
1537 
1538     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to control codec"});
1539   \}
1540   \textcolor{keywordflow}{if} (stream->config.film\_grain\_filename) \{
1541     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
1542                        stream->config.film\_grain\_filename);
1543   \}
1544 
1545 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1546   \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF) \{
1547     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(global->codec->name);
1548     \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
1549     \hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&stream->decoder, decoder->codec\_interface(), &
      \hyperlink{structaom__codec__enc__cfg_a91c4b8e91211a9cea98a8003ef2e4e65}{cfg}, 0);
1550 
1551     \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1552       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE},
1553                         stream->config.cfg.large\_scale\_tile);
1554       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_mode"});
1555 
1556       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB},
1557                         stream->config.cfg.save\_as\_annexb);
1558       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set is\_annexb"});
1559 
1560       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, -1);
1561       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_row"});
1562 
1563       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, AV1\_SET\_DECODE\_TILE\_COL, -1);
1564       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_col"});
1565     \}
1566   \}
1567 \textcolor{preprocessor}{#endif}
1568 \}
1569 
1570 \textcolor{keyword}{static} \textcolor{keywordtype}{void} encode\_frame(\textcolor{keyword}{struct} stream\_state *stream,
1571                          \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keyword}{struct} \hyperlink{structaom__image}{aom\_image} *img,
1572                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_in) \{
1573   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} frame\_start, next\_frame\_start;
1574   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1575   \textcolor{keyword}{struct }aom\_usec\_timer timer;
1576 
1577   frame\_start =
1578       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in - 1) * global->framerate.den) /
1579       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1580   next\_frame\_start =
1581       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in)*global->framerate.den) /
1582       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1583 
1584   \textcolor{comment}{/* Scale if necessary */}
1585   \textcolor{keywordflow}{if} (img) \{
1586     \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) &&
1587         (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1588       \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
1589         fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 inputs\(\backslash\)n"}, exec\_name);
1590         exit(EXIT\_FAILURE);
1591       \}
1592 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1593       \textcolor{keywordflow}{if} (!stream->img) \{
1594         stream->img =
1595             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1596       \}
1597       I420Scale\_16(
1598           (uint16 *)img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2,
1599           (uint16 *)img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_U] / 2,
1600           (uint16 *)img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_V] / 2,
1601           img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16 *)stream->img->planes[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1602           stream->img->stride[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2,
1603           (uint16 *)stream->img->planes[AOM\_PLANE\_U],
1604           stream->img->stride[AOM\_PLANE\_U] / 2,
1605           (uint16 *)stream->img->planes[AOM\_PLANE\_V],
1606           stream->img->stride[AOM\_PLANE\_V] / 2, stream->img->d\_w,
1607           stream->img->d\_h, kFilterBox);
1608       img = stream->img;
1609 \textcolor{preprocessor}{#else}
1610       stream->encoder.err = 1;
1611       ctx\_exit\_on\_error(&stream->encoder,
1612                         \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1613                         \textcolor{stringliteral}{"libyuv is required for scaling but is currently "}
1614                         \textcolor{stringliteral}{"disabled.\(\backslash\)n"}
1615                         \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running "}
1616                         \textcolor{stringliteral}{"cmake.\(\backslash\)n"},
1617                         stream->index);
1618 \textcolor{preprocessor}{#endif}
1619     \}
1620   \}
1621   \textcolor{keywordflow}{if} (img && (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1622     \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) \{
1623       fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 8bpp inputs\(\backslash\)n"}, exec\_name);
1624       exit(EXIT\_FAILURE);
1625     \}
1626 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1627     \textcolor{keywordflow}{if} (!stream->img)
1628       stream->img =
1629           \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1630     I420Scale(
1631         img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1632         img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_U],
1633         img->\hyperlink{structaom__image_ae099696d016f0ff823aaa5dac5fbf2c1}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a97ca7a8d5d722a0bb8e81d4f9c3e94ff}{stride}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
1634         stream->img->planes[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], stream->img->stride[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1635         stream->img->planes[AOM\_PLANE\_U], stream->img->stride[AOM\_PLANE\_U],
1636         stream->img->planes[AOM\_PLANE\_V], stream->img->stride[AOM\_PLANE\_V],
1637         stream->img->d\_w, stream->img->d\_h, kFilterBox);
1638     img = stream->img;
1639 \textcolor{preprocessor}{#else}
1640     stream->encoder.err = 1;
1641     ctx\_exit\_on\_error(&stream->encoder,
1642                       \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1643                       \textcolor{stringliteral}{"Scaling disabled in this configuration. \(\backslash\)n"}
1644                       \textcolor{stringliteral}{"To enable, configure with --enable-libyuv\(\backslash\)n"},
1645                       stream->index);
1646 \textcolor{preprocessor}{#endif}
1647   \}
1648 
1649   aom\_usec\_timer\_start(&timer);
1650   \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(&stream->encoder, img, frame\_start,
1651                    (uint32\_t)(next\_frame\_start - frame\_start), 0);
1652   aom\_usec\_timer\_mark(&timer);
1653   stream->cx\_time += aom\_usec\_timer\_elapsed(&timer);
1654   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Stream %d: Failed to encode frame"},
1655                     stream->index);
1656 \}
1657 
1658 \textcolor{keyword}{static} \textcolor{keywordtype}{void} update\_quantizer\_histogram(\textcolor{keyword}{struct} stream\_state *stream) \{
1659   \textcolor{keywordflow}{if} (stream->config.cfg.g\_pass != \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \{
1660     \textcolor{keywordtype}{int} q;
1661 
1662     \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17b924cadd3c942f9e57fe6fc4d5e2ab}{AOME\_GET\_LAST\_QUANTIZER\_64}, &q);
1663     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to read quantizer"});
1664     stream->counts[q]++;
1665   \}
1666 \}
1667 
1668 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_cx\_data(\textcolor{keyword}{struct} stream\_state *stream,
1669                         \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} *got\_data) \{
1670   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt;
1671   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1672   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
1673 
1674   *got\_data = 0;
1675   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(&stream->encoder, &iter))) \{
1676     \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} fsize = 0;
1677     \textcolor{keyword}{static} FileOffset ivf\_header\_pos = 0;
1678 
1679     \textcolor{keywordflow}{switch} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind}) \{
1680       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}:
1681         \textcolor{keywordflow}{if} (!(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gac7ed4e63a83eb9a31886dc7d584d1fc0}{AOM\_FRAME\_IS\_FRAGMENT})) \{
1682           stream->frames\_out++;
1683         \}
1684         \textcolor{keywordflow}{if} (!global->quiet)
1685           fprintf(stderr, \textcolor{stringliteral}{" %6luF"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
1686 
1687         update\_rate\_histogram(stream->rate\_hist, cfg, pkt);
1688 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1689         \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1690           write\_webm\_block(&stream->webm\_ctx, cfg, pkt);
1691         \}
1692 \textcolor{preprocessor}{#endif}
1693         \textcolor{keywordflow}{if} (!stream->config.write\_webm) \{
1694           \textcolor{keywordflow}{if} (stream->config.write\_ivf) \{
1695             \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.partition\_id <= 0) \{
1696               ivf\_header\_pos = ftello(stream->file);
1697               fsize = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1698 
1699               ivf\_write\_frame\_header(stream->file, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts, fsize);
1700             \} \textcolor{keywordflow}{else} \{
1701               fsize += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1702 
1703               \textcolor{keywordflow}{if} (!(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gac7ed4e63a83eb9a31886dc7d584d1fc0}{AOM\_FRAME\_IS\_FRAGMENT})) \{
1704                 \textcolor{keyword}{const} FileOffset currpos = ftello(stream->file);
1705                 fseeko(stream->file, ivf\_header\_pos, SEEK\_SET);
1706                 ivf\_write\_frame\_size(stream->file, fsize);
1707                 fseeko(stream->file, currpos, SEEK\_SET);
1708               \}
1709             \}
1710           \}
1711 
1712           (void)fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
1713                        stream->file);
1714         \}
1715         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1716 
1717         *got\_data = 1;
1718 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1719         \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF && !stream->mismatch\_seen) \{
1720           \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&stream->decoder, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
1721                            pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL);
1722           \textcolor{keywordflow}{if} (stream->decoder.err) \{
1723             warn\_or\_exit\_on\_error(&stream->decoder,
1724                                   global->test\_decode == TEST\_DECODE\_FATAL,
1725                                   \textcolor{stringliteral}{"Failed to decode frame %d in stream %d"},
1726                                   stream->frames\_out + 1, stream->index);
1727             stream->mismatch\_seen = stream->frames\_out + 1;
1728           \}
1729         \}
1730 \textcolor{preprocessor}{#endif}
1731         \textcolor{keywordflow}{break};
1732       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}:
1733         stream->frames\_out++;
1734         stats\_write(&stream->stats, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf},
1735                     pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz});
1736         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1737         \textcolor{keywordflow}{break};
1738 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1739       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfedaaa76df44da4c92b08150b8a5326f5ebe}{AOM\_CODEC\_FPMB\_STATS\_PKT}:
1740         stats\_write(&stream->fpmb\_stats, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a8ce39bab39da5a247a27e42eb78386e2}{firstpass\_mb\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf},
1741                     pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a8ce39bab39da5a247a27e42eb78386e2}{firstpass\_mb\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz});
1742         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1743         \textcolor{keywordflow}{break};
1744 \textcolor{preprocessor}{#endif}
1745       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda3293bb764f30c11e9583510029578b75}{AOM\_CODEC\_PSNR\_PKT}:
1746 
1747         \textcolor{keywordflow}{if} (global->show\_psnr) \{
1748           \textcolor{keywordtype}{int} i;
1749 
1750           stream->psnr\_sse\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.sse[0];
1751           stream->psnr\_samples\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.samples[0];
1752           \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
1753             \textcolor{keywordflow}{if} (!global->quiet)
1754               fprintf(stderr, \textcolor{stringliteral}{"%.3f "}, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i]);
1755             stream->psnr\_totals[i] += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i];
1756           \}
1757           stream->psnr\_count++;
1758         \}
1759 
1760         \textcolor{keywordflow}{break};
1761       \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
1762     \}
1763   \}
1764 \}
1765 
1766 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_psnr(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{double} peak, int64\_t bps) \{
1767   \textcolor{keywordtype}{int} i;
1768   \textcolor{keywordtype}{double} ovpsnr;
1769 
1770   \textcolor{keywordflow}{if} (!stream->psnr\_count) \textcolor{keywordflow}{return};
1771 
1772   fprintf(stderr, \textcolor{stringliteral}{"Stream %d PSNR (Overall/Avg/Y/U/V)"}, stream->index);
1773   ovpsnr = sse\_to\_psnr((\textcolor{keywordtype}{double})stream->psnr\_samples\_total, peak,
1774                        (\textcolor{keywordtype}{double})stream->psnr\_sse\_total);
1775   fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, ovpsnr);
1776 
1777   \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
1778     fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, stream->psnr\_totals[i] / stream->psnr\_count);
1779   \}
1780   \textcolor{keywordflow}{if} (bps > 0) \{
1781     fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" bps"}, bps);
1782   \}
1783   fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" ms"}, stream->cx\_time / 1000);
1784   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
1785 \}
1786 
1787 \textcolor{keyword}{static} \textcolor{keywordtype}{float} usec\_to\_fps(uint64\_t usec, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames) \{
1788   \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float})(usec > 0 ? frames * 1000000.0 / (float)usec : 0);
1789 \}
1790 
1791 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_decode(\textcolor{keyword}{struct} stream\_state *stream,
1792                         \textcolor{keyword}{enum} TestDecodeFatality fatal) \{
1793   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
1794 
1795   \textcolor{keywordflow}{if} (stream->mismatch\_seen) \textcolor{keywordflow}{return};
1796 
1797   \textcolor{comment}{/* Get the internal reference frame */}
1798   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      enc\_img);
1799   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      dec\_img);
1800 
1801   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
1802       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
1803     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
1804       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
1805       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
1806                     enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
1807       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
1808       enc\_img = enc\_hbd\_img;
1809     \}
1810     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
1811       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
1812       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
1813                     dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
1814       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
1815       dec\_img = dec\_hbd\_img;
1816     \}
1817   \}
1818 
1819   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
1820   ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
1821 
1822   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
1823     \textcolor{keywordtype}{int} y[4], u[4], v[4];
1824     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
1825       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
1826     \} \textcolor{keywordflow}{else} \{
1827       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
1828     \}
1829     stream->decoder.err = 1;
1830     warn\_or\_exit\_on\_error(&stream->decoder, fatal == TEST\_DECODE\_FATAL,
1831                           \textcolor{stringliteral}{"Stream %d: Encode/decode mismatch on frame %d at"}
1832                           \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
1833                           \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
1834                           \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
1835                           stream->index, stream->frames\_out, y[0], y[1], y[2],
1836                           y[3], u[0], u[1], u[2], u[3], v[0], v[1], v[2], v[3]);
1837     stream->mismatch\_seen = stream->frames\_out;
1838   \}
1839 
1840   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
1841   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
1842 \}
1843 
1844 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_time(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *label, int64\_t etl) \{
1845   int64\_t hours;
1846   int64\_t mins;
1847   int64\_t secs;
1848 
1849   \textcolor{keywordflow}{if} (etl >= 0) \{
1850     hours = etl / 3600;
1851     etl -= hours * 3600;
1852     mins = etl / 60;
1853     etl -= mins * 60;
1854     secs = etl;
1855 
1856     fprintf(stderr, \textcolor{stringliteral}{"[%3s %2"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{"] "}, label,
1857             hours, mins, secs);
1858   \} \textcolor{keywordflow}{else} \{
1859     fprintf(stderr, \textcolor{stringliteral}{"[%3s  unknown] "}, label);
1860   \}
1861 \}
1862 
1863 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
1864   \textcolor{keywordtype}{int} pass;
1865   \hyperlink{structaom__image}{aom\_image\_t} raw;
1866   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
1867   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
1868   \textcolor{keywordtype}{int} use\_16bit\_internal = 0;
1869   \textcolor{keywordtype}{int} input\_shift = 0;
1870   \textcolor{keywordtype}{int} frame\_avail, got\_data;
1871 
1872   \textcolor{keyword}{struct }AvxInputContext input;
1873   \textcolor{keyword}{struct }AvxEncoderConfig global;\textcolor{comment}{//}
1874   \textcolor{keyword}{struct }stream\_state *streams = NULL;
1875   \textcolor{keywordtype}{char} **argv, **argi;
1876   uint64\_t cx\_time = 0;
1877   \textcolor{keywordtype}{int} stream\_cnt = 0;
1878   \textcolor{keywordtype}{int} res = 0;
1879   \textcolor{keywordtype}{int} profile\_updated = 0;
1880 
1881   memset(&input, 0, \textcolor{keyword}{sizeof}(input));
1882   exec\_name = argv\_[0];
1883 
1884   \textcolor{comment}{/* Setup default input stream settings */}
1885   input.framerate.numerator = 30;\textcolor{comment}{//}
1886   input.framerate.denominator = 1;\textcolor{comment}{//1/30}
1887   input.only\_i420 = 1;
1888   input.bit\_depth = 0;
1889 
1890   \textcolor{comment}{/* First parse the global configuration values, because we want to apply}
1891 \textcolor{comment}{   * other parameters on top of the default configuration provided by the}
1892 \textcolor{comment}{   * codec.}
1893 \textcolor{comment}{   */}
1894   argv = argv\_dup(argc - 1, argv\_ + 1);
1895   parse\_global\_config(&global, &argc, &argv);
1896 
1897 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1898   \textcolor{keywordflow}{if} (argc < 2) usage\_exit();
1899 \textcolor{preprocessor}{#else}
1900   \textcolor{keywordflow}{if} (argc < 3) usage\_exit();
1901 \textcolor{preprocessor}{#endif}
1902 
1903   \textcolor{keywordflow}{switch} (global.color\_type) \{\textcolor{comment}{//4:2:0,4:2:2}
1904     \textcolor{keywordflow}{case} I420: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}; \textcolor{keywordflow}{break};
1905     \textcolor{keywordflow}{case} I422: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}; \textcolor{keywordflow}{break};
1906     \textcolor{keywordflow}{case} I444: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}; \textcolor{keywordflow}{break};
1907     \textcolor{keywordflow}{case} YV12: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}; \textcolor{keywordflow}{break};
1908   \}
1909 
1910   \{
1911     \textcolor{comment}{/* Now parse each stream's parameters. Using a local scope here}
1912 \textcolor{comment}{     * due to the use of 'stream' as loop variable in FOREACH\_STREAM}
1913 \textcolor{comment}{     * loops}
1914 \textcolor{comment}{     */}
1915     \textcolor{keyword}{struct }stream\_state *stream = NULL;
1916 
1917     \textcolor{comment}{//}
1918     \textcolor{keywordflow}{do} \{
1919       stream = new\_stream(&global, stream);
1920       stream\_cnt++;
1921       \textcolor{keywordflow}{if} (!streams) streams = stream;
1922     \} \textcolor{keywordflow}{while} (parse\_stream\_params(&global, stream, argv));
1923   \}
1924 
1925   \textcolor{comment}{/* Check for unrecognized options */}
1926   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
1927     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && argi[0][1])
1928       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
1929 
1930   FOREACH\_STREAM(stream, streams) \{
1931     check\_encoder\_config(global.disable\_warning\_prompt, &global,
1932                          &stream->config.cfg);
1933   \}
1934 
1935   \textcolor{comment}{/* Handle non-option arguments */}
1936   input.filename = argv[0];
1937 
1938   \textcolor{keywordflow}{if} (!input.filename) \{
1939     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
1940     usage\_exit();
1941   \}
1942 
1943   \textcolor{comment}{/* Decide if other chroma subsamplings than 4:2:0 are supported */}
1944   \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) input.only\_i420 = 0;
1945 
1946   \textcolor{keywordflow}{for} (pass = global.pass ? global.pass - 1 : 0; pass < global.passes; pass++) \{
1947     \textcolor{keywordtype}{int} frames\_in = 0, seen\_frames = 0;
1948     int64\_t estimated\_time\_left = -1;
1949     int64\_t average\_rate = -1;
1950     int64\_t lagged\_count = 0;
1951 
1952     open\_input\_file(&input);
1953 
1954     \textcolor{comment}{/* If the input file doesn't specify() its w/h (raw files), try to get}
1955 \textcolor{comment}{     * the data from the first stream's configuration.}
1956 \textcolor{comment}{     */}
1957     \textcolor{keywordflow}{if} (!input.width || !input.height) \{
1958       FOREACH\_STREAM(stream, streams) \{
1959         \textcolor{keywordflow}{if} (stream->config.cfg.g\_w && stream->config.cfg.g\_h) \{
1960           input.width = stream->config.cfg.g\_w;
1961           input.height = stream->config.cfg.g\_h;
1962           \textcolor{keywordflow}{break};
1963         \}
1964       \};
1965     \}
1966 
1967     \textcolor{comment}{/* Update stream configurations from the input file's parameters */}
1968     \textcolor{keywordflow}{if} (!input.width || !input.height)
1969       fatal(
1970           \textcolor{stringliteral}{"Specify stream dimensions with --width (-w) "}
1971           \textcolor{stringliteral}{" and --height (-h)"});
1972 
1973     \textcolor{comment}{/* If input file does not specify bit-depth but input-bit-depth parameter}
1974 \textcolor{comment}{     * exists, assume that to be the input bit-depth. However, if the}
1975 \textcolor{comment}{     * input-bit-depth paramter does not exist, assume the input bit-depth}
1976 \textcolor{comment}{     * to be the same as the codec bit-depth.}
1977 \textcolor{comment}{     */}
1978     \textcolor{keywordflow}{if} (!input.bit\_depth) \{
1979       FOREACH\_STREAM(stream, streams) \{
1980         \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth)
1981           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
1982         \textcolor{keywordflow}{else}
1983           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth =
1984               (int)stream->config.cfg.g\_bit\_depth;
1985       \}
1986       \textcolor{keywordflow}{if} (input.bit\_depth > 8) input.fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
1987     \} \textcolor{keywordflow}{else} \{
1988       FOREACH\_STREAM(stream, streams) \{
1989         stream->config.cfg.g\_input\_bit\_depth = input.bit\_depth;
1990       \}
1991     \}
1992 
1993     FOREACH\_STREAM(stream, streams) \{
1994       \textcolor{keywordflow}{if} (input.fmt != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && input.fmt != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
1995         \textcolor{comment}{/* Automatically upgrade if input is non-4:2:0 but a 4:2:0 profile}
1996 \textcolor{comment}{           was selected. */}
1997         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
1998           \textcolor{keywordflow}{case} 0:
1999             \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2000                                          input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2001               \textcolor{keywordflow}{if} (!stream->config.cfg.monochrome) \{
2002                 stream->config.cfg.g\_profile = 1;
2003                 profile\_updated = 1;
2004               \}
2005             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2006                        input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2007               stream->config.cfg.g\_profile = 2;
2008               profile\_updated = 1;
2009             \}
2010             \textcolor{keywordflow}{break};
2011           \textcolor{keywordflow}{case} 1:
2012             \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2013                 input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2014               stream->config.cfg.g\_profile = 2;
2015               profile\_updated = 1;
2016             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2017                        (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2018                         input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2019               stream->config.cfg.g\_profile = 0;
2020               profile\_updated = 1;
2021             \}
2022             \textcolor{keywordflow}{break};
2023           \textcolor{keywordflow}{case} 2:
2024             \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2025                                          input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2026               stream->config.cfg.g\_profile = 1;
2027               profile\_updated = 1;
2028             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2029                        (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2030                         input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2031               stream->config.cfg.g\_profile = 0;
2032               profile\_updated = 1;
2033             \}
2034             \textcolor{keywordflow}{break};
2035           \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2036         \}
2037       \}
2038       \textcolor{comment}{/* Automatically set the codec bit depth to match() the input bit depth.}
2039 \textcolor{comment}{       * Upgrade the profile if required. */}
2040       \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth >
2041           (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth) \{
2042         stream->config.cfg.g\_bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
2043       \}
2044       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 10) \{
2045         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
2046           \textcolor{keywordflow}{case} 0:
2047           \textcolor{keywordflow}{case} 1:
2048             stream->config.cfg.g\_profile = 2;
2049             profile\_updated = 1;
2050             \textcolor{keywordflow}{break};
2051           \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2052         \}
2053       \}
2054       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 8) \{
2055         stream->config.use\_16bit\_internal = 1;
2056       \}
2057       \textcolor{keywordflow}{if} (profile\_updated && !global.quiet) \{
2058         fprintf(stderr,
2059                 \textcolor{stringliteral}{"Warning: automatically updating to profile %d to "}
2060                 \textcolor{stringliteral}{"match input format.\(\backslash\)n"},
2061                 stream->config.cfg.g\_profile);
2062       \}
2063       \textcolor{comment}{/* Set limit */}
2064       stream->config.cfg.g\_limit = global.limit;
2065     \}
2066 
2067     FOREACH\_STREAM(stream, streams) \{
2068       set\_stream\_dimensions(stream, input.width, input.height);
2069     \}
2070     FOREACH\_STREAM(stream, streams) \{ validate\_stream\_config(stream, &global); \}
2071 
2072     \textcolor{comment}{/* Ensure that --passes and --pass are consistent. If --pass is set and}
2073 \textcolor{comment}{     * --passes=2, ensure --fpf was set.}
2074 \textcolor{comment}{     */}
2075     \textcolor{keywordflow}{if} (global.pass && global.passes == 2) \{
2076       FOREACH\_STREAM(stream, streams) \{
2077         \textcolor{keywordflow}{if} (!stream->config.stats\_fn)
2078           die(\textcolor{stringliteral}{"Stream %d: Must specify --fpf when --pass=%d"}
2079               \textcolor{stringliteral}{" and --passes=2\(\backslash\)n"},
2080               stream->index, global.pass);
2081       \}
2082     \}
2083 
2084 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
2085     FOREACH\_STREAM(stream, streams) \{
2086       \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
2087         stream->config.write\_webm = 0;
2088         stream->config.write\_ivf = 0;
2089         warn(\textcolor{stringliteral}{"aomenc compiled w/o WebM support. Writing OBU stream."});
2090       \}
2091     \}
2092 \textcolor{preprocessor}{#endif}
2093 
2094     \textcolor{comment}{/* Use the frame rate from the file only if none was specified}
2095 \textcolor{comment}{     * on the command-line.}
2096 \textcolor{comment}{     */}
2097     \textcolor{keywordflow}{if} (!global.have\_framerate) \{
2098       global.framerate.num = input.framerate.numerator;
2099       global.framerate.den = input.framerate.denominator;
2100     \}
2101     FOREACH\_STREAM(stream, streams) \{
2102       stream->config.cfg.g\_timebase.den = global.framerate.num;
2103       stream->config.cfg.g\_timebase.num = global.framerate.den;
2104     \}
2105     \textcolor{comment}{/* Show configuration */}
2106     \textcolor{keywordflow}{if} (global.verbose && pass == 0) \{
2107       FOREACH\_STREAM(stream, streams) \{
2108         show\_stream\_config(stream, &global, &input);
2109       \}
2110     \}
2111 
2112     \textcolor{keywordflow}{if} (pass == (global.pass ? global.pass - 1 : 0)) \{
2113       \textcolor{keywordflow}{if} (input.file\_type == FILE\_TYPE\_Y4M)
2114         \textcolor{comment}{/*The Y4M reader does its own allocation.}
2115 \textcolor{comment}{          Just initialize this here to avoid problems if we never read any}
2116 \textcolor{comment}{          frames.*/}
2117         memset(&raw, 0, \textcolor{keyword}{sizeof}(raw));
2118       \textcolor{keywordflow}{else}
2119         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, input.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, input.width, input.height, 32);
2120 
2121       FOREACH\_STREAM(stream, streams) \{
2122         stream->rate\_hist =
2123             init\_rate\_histogram(&stream->config.cfg, &global.framerate);
2124       \}
2125     \}
2126 
2127     FOREACH\_STREAM(stream, streams) \{ setup\_pass(stream, &global, pass); \}
2128     FOREACH\_STREAM(stream, streams) \{
2129       open\_output\_file(stream, &global, &input.pixel\_aspect\_ratio);
2130     \}
2131     FOREACH\_STREAM(stream, streams) \{ initialize\_encoder(stream, &global); \}
2132     \textcolor{keywordflow}{if} (strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0 ||
2133         strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
2134       \textcolor{comment}{// Check to see if at least one stream uses 16 bit internal.}
2135       \textcolor{comment}{// Currently assume that the bit\_depths for all streams using}
2136       \textcolor{comment}{// highbitdepth are the same.}
2137       FOREACH\_STREAM(stream, streams) \{
2138         \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal) \{
2139           use\_16bit\_internal = 1;
2140         \}
2141         input\_shift = (int)stream->config.cfg.g\_bit\_depth -
2142                       stream->config.cfg.g\_input\_bit\_depth;
2143       \};
2144     \}
2145 
2146     frame\_avail = 1;
2147     got\_data = 0;
2148 
2149     \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
2150       \textcolor{keyword}{struct }aom\_usec\_timer timer;
2151 
2152       \textcolor{keywordflow}{if} (!global.limit || frames\_in < global.limit) \{
2153         frame\_avail = read\_frame(&input, &raw);
2154 
2155         \textcolor{keywordflow}{if} (frame\_avail) frames\_in++;
2156         seen\_frames =
2157             frames\_in > global.skip\_frames ? frames\_in - global.skip\_frames : 0;
2158 
2159         \textcolor{keywordflow}{if} (!global.quiet) \{
2160           \textcolor{keywordtype}{float} fps = usec\_to\_fps(cx\_time, seen\_frames);
2161           fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d "}, pass + 1, global.passes);
2162 
2163           \textcolor{keywordflow}{if} (stream\_cnt == 1)
2164             fprintf(stderr, \textcolor{stringliteral}{"frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B "}, frames\_in,
2165                     streams->frames\_out, (int64\_t)streams->nbytes);
2166           \textcolor{keywordflow}{else}
2167             fprintf(stderr, \textcolor{stringliteral}{"frame %4d "}, frames\_in);
2168 
2169           fprintf(stderr, \textcolor{stringliteral}{"%7"} PRId64 \textcolor{stringliteral}{" %s %.2f %s "},
2170                   cx\_time > 9999999 ? cx\_time / 1000 : cx\_time,
2171                   cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"}, fps >= 1.0 ? fps : fps * 60,
2172                   fps >= 1.0 ? \textcolor{stringliteral}{"fps"} : \textcolor{stringliteral}{"fpm"});
2173           print\_time(\textcolor{stringliteral}{"ETA"}, estimated\_time\_left);
2174         \}
2175 
2176       \} \textcolor{keywordflow}{else} \{
2177         frame\_avail = 0;
2178       \}
2179 
2180       \textcolor{keywordflow}{if} (frames\_in > global.skip\_frames) \{
2181         \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
2182         \textcolor{keywordflow}{if} (input\_shift || (use\_16bit\_internal && input.bit\_depth == 8)) \{
2183           assert(use\_16bit\_internal);
2184           \textcolor{comment}{// Input bit depth and stream bit depth do not match, so up}
2185           \textcolor{comment}{// shift frame to stream bit depth}
2186           \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
2187             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2188                           input.width, input.height, 32);
2189             allocated\_raw\_shift = 1;
2190           \}
2191           aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
2192           frame\_to\_encode = &raw\_shift;
2193         \} \textcolor{keywordflow}{else} \{
2194           frame\_to\_encode = &raw;
2195         \}
2196         aom\_usec\_timer\_start(&timer);
2197         \textcolor{keywordflow}{if} (use\_16bit\_internal) \{
2198           assert(frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH});
2199           FOREACH\_STREAM(stream, streams) \{
2200             \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal)
2201               encode\_frame(stream, &global,
2202                            frame\_avail ? frame\_to\_encode : NULL, frames\_in);
2203             \textcolor{keywordflow}{else}
2204               assert(0);
2205           \};
2206         \} \textcolor{keywordflow}{else} \{
2207           assert((frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) == 0);
2208           FOREACH\_STREAM(stream, streams) \{
2209             encode\_frame(stream, &global, frame\_avail ? frame\_to\_encode : NULL,
2210                          frames\_in);
2211           \}
2212         \}
2213         aom\_usec\_timer\_mark(&timer);
2214         cx\_time += aom\_usec\_timer\_elapsed(&timer);
2215 
2216         FOREACH\_STREAM(stream, streams) \{ update\_quantizer\_histogram(stream); \}
2217 
2218         got\_data = 0;
2219         FOREACH\_STREAM(stream, streams) \{
2220           get\_cx\_data(stream, &global, &got\_data);
2221         \}
2222 
2223         \textcolor{keywordflow}{if} (!got\_data && input.length && streams != NULL &&
2224             !streams->frames\_out) \{
2225           lagged\_count = global.limit ? seen\_frames : ftello(input.file);
2226         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.length) \{
2227           int64\_t remaining;
2228           int64\_t rate;
2229 
2230           \textcolor{keywordflow}{if} (global.limit) \{
2231             \textcolor{keyword}{const} int64\_t frame\_in\_lagged = (seen\_frames - lagged\_count) * 1000;
2232 
2233             rate = cx\_time ? frame\_in\_lagged * (int64\_t)1000000 / cx\_time : 0;
2234             remaining = 1000 * (global.limit - global.skip\_frames -
2235                                 seen\_frames + lagged\_count);
2236           \} \textcolor{keywordflow}{else} \{
2237             \textcolor{keyword}{const} int64\_t input\_pos = ftello(input.file);
2238             \textcolor{keyword}{const} int64\_t input\_pos\_lagged = input\_pos - lagged\_count;
2239             \textcolor{keyword}{const} int64\_t input\_limit = input.length;
2240 
2241             rate = cx\_time ? input\_pos\_lagged * (int64\_t)1000000 / cx\_time : 0;
2242             remaining = input\_limit - input\_pos + lagged\_count;
2243           \}
2244 
2245           average\_rate =
2246               (average\_rate <= 0) ? rate : (average\_rate * 7 + rate) / 8;
2247           estimated\_time\_left = average\_rate ? remaining / average\_rate : -1;
2248         \}
2249 
2250         \textcolor{keywordflow}{if} (got\_data && global.test\_decode != TEST\_DECODE\_OFF) \{
2251           FOREACH\_STREAM(stream, streams) \{
2252             test\_decode(stream, global.test\_decode);
2253           \}
2254         \}
2255       \}
2256 
2257       fflush(stdout);
2258       \textcolor{keywordflow}{if} (!global.quiet) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)033[K"});
2259     \}
2260 
2261     \textcolor{keywordflow}{if} (stream\_cnt > 1) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
2262 
2263     \textcolor{keywordflow}{if} (!global.quiet) \{
2264       FOREACH\_STREAM(stream, streams) \{
2265         \textcolor{keyword}{const} int64\_t bpf =
2266             seen\_frames ? (int64\_t)(stream->nbytes * 8 / seen\_frames) : 0;
2267         \textcolor{keyword}{const} int64\_t bps = bpf * global.framerate.num / global.framerate.den;
2268         fprintf(stderr,
2269                 \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B %7"} PRId64
2270                 \textcolor{stringliteral}{"b/f %7"} PRId64
2271                 \textcolor{stringliteral}{"b/s"}
2272                 \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" %s (%.2f fps)\(\backslash\)033[K\(\backslash\)n"},
2273                 pass + 1, global.passes, frames\_in, stream->frames\_out,
2274                 (int64\_t)stream->nbytes, bpf, bps,
2275                 stream->cx\_time > 9999999 ? stream->cx\_time / 1000
2276                                           : stream->cx\_time,
2277                 stream->cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"},
2278                 usec\_to\_fps(stream->cx\_time, seen\_frames));
2279       \}
2280     \}
2281 
2282     \textcolor{keywordflow}{if} (global.show\_psnr) \{
2283       \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) \{
2284         FOREACH\_STREAM(stream, streams) \{
2285           int64\_t bps = 0;
2286           \textcolor{keywordflow}{if} (stream->psnr\_count && seen\_frames && global.framerate.den) \{
2287             bps = (int64\_t)stream->nbytes * 8 * (int64\_t)global.framerate.num /
2288                   global.framerate.den / seen\_frames;
2289           \}
2290           show\_psnr(stream, (1 << stream->config.cfg.g\_input\_bit\_depth) - 1,
2291                     bps);
2292         \}
2293       \} \textcolor{keywordflow}{else} \{
2294         FOREACH\_STREAM(stream, streams) \{ show\_psnr(stream, 255.0, 0); \}
2295       \}
2296     \}
2297 
2298     FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->encoder); \}
2299 
2300     \textcolor{keywordflow}{if} (global.test\_decode != TEST\_DECODE\_OFF) \{
2301       FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->decoder); \}
2302     \}
2303 
2304     close\_input\_file(&input);
2305 
2306     \textcolor{keywordflow}{if} (global.test\_decode == TEST\_DECODE\_FATAL) \{
2307       FOREACH\_STREAM(stream, streams) \{ res |= stream->mismatch\_seen; \}
2308     \}
2309     FOREACH\_STREAM(stream, streams) \{
2310       close\_output\_file(stream, global.codec->fourcc);
2311     \}
2312 
2313     FOREACH\_STREAM(stream, streams) \{
2314       stats\_close(&stream->stats, global.passes - 1);
2315     \}
2316 
2317 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
2318     FOREACH\_STREAM(stream, streams) \{
2319       stats\_close(&stream->fpmb\_stats, global.passes - 1);
2320     \}
2321 \textcolor{preprocessor}{#endif}
2322 
2323     \textcolor{keywordflow}{if} (global.pass) \textcolor{keywordflow}{break};
2324   \}
2325 
2326   \textcolor{keywordflow}{if} (global.show\_q\_hist\_buckets) \{
2327     FOREACH\_STREAM(stream, streams) \{
2328       show\_q\_histogram(stream->counts, global.show\_q\_hist\_buckets);
2329     \}
2330   \}
2331 
2332   \textcolor{keywordflow}{if} (global.show\_rate\_hist\_buckets) \{
2333     FOREACH\_STREAM(stream, streams) \{
2334       show\_rate\_histogram(stream->rate\_hist, &stream->config.cfg,
2335                           global.show\_rate\_hist\_buckets);
2336     \}
2337   \}
2338   FOREACH\_STREAM(stream, streams) \{ destroy\_rate\_histogram(stream->rate\_hist); \}
2339 
2340 \textcolor{preprocessor}{#if CONFIG\_INTERNAL\_STATS}
2341   \textcolor{comment}{/* TODO(jkoleszar): This doesn't belong in this executable. Do it for now,}
2342 \textcolor{comment}{   * to match some existing utilities.}
2343 \textcolor{comment}{   */}
2344   \textcolor{keywordflow}{if} (!(global.pass == 1 && global.passes == 2)) \{
2345     FOREACH\_STREAM(stream, streams) \{
2346       FILE *f = fopen(\textcolor{stringliteral}{"opsnr.stt"}, \textcolor{stringliteral}{"a"});
2347       \textcolor{keywordflow}{if} (stream->mismatch\_seen) \{
2348         fprintf(f, \textcolor{stringliteral}{"First mismatch occurred in frame %d\(\backslash\)n"},
2349                 stream->mismatch\_seen);
2350       \} \textcolor{keywordflow}{else} \{
2351         fprintf(f, \textcolor{stringliteral}{"No mismatch detected in recon buffers\(\backslash\)n"});
2352       \}
2353       fclose(f);
2354     \}
2355   \}
2356 \textcolor{preprocessor}{#endif}
2357 
2358   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
2359   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
2360   free(argv);
2361   free(streams);
2362   \textcolor{keywordflow}{return} res ? EXIT\_FAILURE : EXIT\_SUCCESS;
2363 \}
\end{DoxyCodeInclude}
 